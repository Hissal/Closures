<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ClosureTests/ActionTests/AnonymousClosure/AnonymousClosureTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/ActionTests/AnonymousClosure/AnonymousClosureTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.ActionTests.AnonymousClosure;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    // Normal Actions&#10;    [Test]&#10;    public void ClosureActionAsAnonymousAndBack() {&#10;        int expected = 10;&#10;        int received = 0;&#10;        &#10;        var closureAction = Closure.Action(expected, context =&gt; received = context);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int&gt;().Invoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context value.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void ClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    [Test]&#10;    public void ClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, ref int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureRefAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    // Mutating Actions&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.ActionTests.AnonymousClosure;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    // Normal Actions&#10;    [Test]&#10;    public void ClosureActionAsAnonymousAndBack() {&#10;        int expected = 10;&#10;        int received = 0;&#10;        &#10;        var closureAction = Closure.Action(expected, context =&gt; received = context);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int&gt;().Invoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context value.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void ClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    [Test]&#10;    public void ClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, ref int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureRefAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    // Mutating Actions&#10;    [Test]&#10;    public void MutatingClosureActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int expected = context + 5;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c) =&gt; c += 5, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureAction&lt;int&gt;().Invoke();&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureAction did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void MutatingClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 7;&#10;        int expected = context + arg;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c, int a) =&gt; c += a, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureActionWithArg did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void MutatingClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c, ref int a) =&gt; c += a, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureRefAction&lt;int, int&gt;().Invoke(ref arg);&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureRefAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureRefAction did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction))]&#10;public class AnonymousClosureActionTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    &#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        a.Invoke();&#10;        &#10;        var b = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction))]&#10;public class AnonymousClosureActionTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    &#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx) =&gt; ctx += addition,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke();&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;&#10;        var anon = AnonymousClosure.Action(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx) =&gt; ctx.testContext.Value = ctx.value = expected,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;        Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        a.Invoke();&#10;        &#10;        var b = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionWithArgTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionWithArgTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction&lt;&gt;))]&#10;public class AnonymousClosureActionWithArgTest {&#10;&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesContext() {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; ctx += addition,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; ctx.testContext.Value = ctx.value = expected,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Anonymous tests&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx * arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(15));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx * arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(20));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        int arg = 1;&#10;        a.Invoke(arg);&#10;&#10;        var b = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction&lt;&gt;))]&#10;public class AnonymousClosureActionWithArgTest {&#10;&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesContext() {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; { Assert.That(ctx, Is.EqualTo(expected)); });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; { ctx.testContext.Value = ctx.expected; });&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; { Assert.That(ctx + a, Is.EqualTo(expected)); });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; { Assert.That(ctx + a, Is.EqualTo(expected)); });&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; { val += ctx; });&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; { val += ctx; });&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; { ctx += addition; },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; { ctx.testContext.Value = ctx.value = expected; },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Anonymous tests&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { calledWith = ctx * arg; };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(15));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { calledWith = ctx * arg; };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(20));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { throw new InvalidCastException(&quot;fail&quot;); };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { throw new InvalidCastException(&quot;fail&quot;); };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        int arg = 1;&#10;        a.Invoke(arg);&#10;&#10;        var b = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureExtensionsTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureExtensionsTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureExtensions))]&#10;public class AnonymousClosureExtensionsTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureExtensions))]&#10;public class AnonymousClosureExtensionsTest {&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;&gt;))]&#10;public class AnonymousClosureFuncTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx;&#10;        });&#10;&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From((testContext, expected)),&#10;            ((TestClass testContext, int expected) ctx) =&gt; {&#10;                ctx.testContext.Value = ctx.expected;&#10;                return ctx.expected;&#10;            });&#10;&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReturnsExpectedValue() {&#10;        int context = 10;&#10;        int expected = context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 2);&#10;&#10;        int result = anon.Invoke();&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx + 1;&#10;&#10;        var a = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;&gt;))]&#10;public class AnonymousClosureFuncTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx;&#10;        });&#10;&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From((testContext, expected)),&#10;            ((TestClass testContext, int expected) ctx) =&gt; {&#10;                ctx.testContext.Value = ctx.expected;&#10;                return ctx.expected;&#10;            });&#10;&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReturnsExpectedValue() {&#10;        int context = 10;&#10;        int expected = context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 2);&#10;&#10;        int result = anon.Invoke();&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvokeBool_ReturnsTrueAndResult_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        bool success = anon.TryInvoke(out int result);&#10;        Assert.That(success, Is.True);&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvokeBool_ReturnsFalseAndDefault_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        bool success = anon.TryInvoke(out int result);&#10;        Assert.That(success, Is.False);&#10;        Assert.That(result, Is.EqualTo(default(int)));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx + 1;&#10;&#10;        var a = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncWithArgTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncWithArgTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;,&gt;))]&#10;public class AnonymousClosureFuncWithArgTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;,&gt;))]&#10;public class AnonymousClosureFuncWithArgTest&#10;{&#10;    class TestClass&#10;    {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesContext()&#10;    {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesTupleContext_AndModifiesTestContextValue()&#10;    {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; {&#10;            ctx.testContext.Value = ctx.expected;&#10;            return ctx.expected + a;&#10;        });&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesArg()&#10;    {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; {&#10;            Assert.That(ctx + a, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesRefArg()&#10;    {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; {&#10;            Assert.That(ctx + a, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ModifiesRefArgValue()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; {&#10;            val += ctx;&#10;            return val;&#10;        });&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ModifiesRefArgValue_MultipleInvocations()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; {&#10;            val += ctx;&#10;            return val;&#10;        });&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_MutatingContext_RetainsModifiedContext()&#10;    {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; {&#10;                ctx += addition;&#10;                return ctx + a;&#10;            },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_MutatingTupleContext_RetainsModifiedContext()&#10;    {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; {&#10;                ctx.testContext.Value = ctx.value = expected;&#10;                return ctx.value + a;&#10;            },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReturnsExpectedValue()&#10;    {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;        int result = anon.Invoke(arg);&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvoke_ReturnsSuccess_OnValidCall()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;&#10;        var result = anon.TryInvoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvoke_ReturnsFailure_OnException()&#10;    {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;));&#10;&#10;        var result = anon.TryInvoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvokeBool_ReturnsTrueAndResult_OnValidCall()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;&#10;        bool success = anon.TryInvoke(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.True);&#10;            Assert.That(result, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvokeBool_ReturnsFalseAndDefault_OnException()&#10;    {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;));&#10;&#10;        bool success = anon.TryInvoke(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.False);&#10;            Assert.That(result, Is.EqualTo(default(int)));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_Equals_And_HashCode_Work()&#10;    {&#10;        int context = 7;&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;&#10;        var a = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke(1);&#10;&#10;        var b = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    // Default tests&#10;        &#10;    [Test]&#10;    public void Action_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        closure.Invoke();&#10;    }&#10;        &#10;    [Test]&#10;    public void Action_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;&#10;        var testContext = new TestClass();&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; { &#10;            ctx.testContext.Value = ctx.expected;&#10;        });&#10;        closure.Invoke();&#10;&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(arg);&#10;    }&#10;    &#10;    // Ref argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(ref arg);&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Mutating tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourMutate_RetainsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context + addition;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Mutate);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourReset_ResetsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Reset);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Func Tests&#10;&#10;    [Test]&#10;    public void Func_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx);&#10;        var result = closure.Invoke&lt;int&gt;();&#10;        &#10;        Assert.That(result, Is.EqualTo(context), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(argument);&#10;        &#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func ref arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithRefArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(ref argument);&#10;&#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Anonymous Action Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Func Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Is_Works() {&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(42), (int ctx) =&gt; { });&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(closure.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True);&#10;            Assert.That(closure.Is&lt;MutatingClosureFunc&lt;int, int&gt;&gt;(), Is.False);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    // Default tests&#10;        &#10;    [Test]&#10;    public void Action_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        closure.Invoke();&#10;    }&#10;        &#10;    [Test]&#10;    public void Action_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;&#10;        var testContext = new TestClass();&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; { &#10;            ctx.testContext.Value = ctx.expected;&#10;        });&#10;        closure.Invoke();&#10;&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(arg);&#10;    }&#10;    &#10;    // Ref argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(ref arg);&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Mutating tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourMutate_RetainsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context + addition;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Mutate);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourReset_ResetsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Reset);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Func Tests&#10;&#10;    [Test]&#10;    public void Func_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx);&#10;        var result = closure.Invoke&lt;int&gt;();&#10;        &#10;        Assert.That(result, Is.EqualTo(context), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(argument);&#10;        &#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func ref arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithRefArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(ref argument);&#10;&#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Anonymous Action Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Func Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Is_Works() {&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(42), (int ctx) =&gt; { });&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(closure.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True);&#10;            Assert.That(closure.Is&lt;MutatingClosureFunc&lt;int, int&gt;&gt;(), Is.False);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;&#10;    // TryInvoke with arg&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(8));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // TryInvoke with ref arg&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithRefArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = closure.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(9));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithRefArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = closure.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke with arg&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx + a);&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke with ref arg&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithRefArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; ctx + a);&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithRefArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke bool out result&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvokeBool_WithArg_ReturnsTrueAndResult_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx + a);&#10;&#10;        bool success = closure.TryInvoke&lt;int, int&gt;(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.True);&#10;            Assert.That(result, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvokeBool_WithArg_ReturnsFalseAndDefault_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        bool success = closure.TryInvoke&lt;int, int&gt;(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.False);&#10;            Assert.That(result, Is.EqualTo(default(int)));&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousHelperTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousHelperTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousHelper))]&#10;public class AnonymousHelperTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;using System;&#10;using System.Linq;&#10;using System.Reflection;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousHelper))]&#10;public class AnonymousHelperTest&#10;{&#10;    private class DummyClosure : IClosure&lt;int, Action&lt;int&gt;&gt;&#10;    {&#10;        public int Context { get; }&#10;        public Action&lt;int&gt; Action { get; }&#10;        public DummyClosure(int ctx, Action&lt;int&gt; action) { Context = ctx; Action = action; }&#10;    }&#10;&#10;    private class DummyAnonymousClosure : IAnonymousClosure&#10;    {&#10;        public AnonymousValue Context { get; set; }&#10;        public Delegate Delegate { get; set; }&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceType_ReturnsCorrectInterface()&#10;    {&#10;        var type = AnonymousHelper.GetInterfaceType&lt;DummyClosure&gt;();&#10;        Assert.That(type, Is.EqualTo(typeof(IClosure&lt;int, Action&lt;int&gt;&gt;)));&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceType_ThrowsIfNoInterface()&#10;    {&#10;        Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; AnonymousHelper.GetInterfaceType&lt;AnonymousHelperTest&gt;());&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceGenericArguments_ReturnsCorrectArguments()&#10;    {&#10;        var iface = typeof(IClosure&lt;int, Action&lt;int&gt;&gt;);&#10;        var args = AnonymousHelper.GetInterfaceGenericArguments(iface);&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(Action&lt;int&gt;) }));&#10;    }&#10;&#10;    [Test]&#10;    public void CanConvert_ReturnsTrueForMatchingTypes()&#10;    {&#10;        var anon = new DummyAnonymousClosure&#10;        {&#10;            Context = AnonymousValue.Int(42),&#10;            Delegate = new Action&lt;int&gt;(_ =&gt; { })&#10;        };&#10;        Assert.That(AnonymousHelper.CanConvert&lt;DummyClosure, DummyAnonymousClosure&gt;(anon), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void CanConvert_ReturnsFalseForMismatchedTypes()&#10;    {&#10;        var anon = new DummyAnonymousClosure&#10;        {&#10;            Context = AnonymousValue.Char('c'),&#10;            Delegate = new Action&lt;string&gt;(_ =&gt; { })&#10;        };&#10;        Assert.That(AnonymousHelper.CanConvert&lt;DummyClosure, DummyAnonymousClosure&gt;(anon), Is.False);&#10;    }&#10;&#10;    [TestCase(typeof(InvalidOperationException), ExpectedResult = false)]&#10;    [TestCase(typeof(InvalidCastException), ExpectedResult = false)]&#10;    [TestCase(typeof(ArgumentException), ExpectedResult = false)]&#10;    [TestCase(typeof(NullReferenceException), ExpectedResult = true)]&#10;    public bool ShouldThrow_Works(Type exceptionType)&#10;    {&#10;        var ex = (Exception)Activator.CreateInstance(exceptionType)!;&#10;        return AnonymousHelper.ShouldThrow(ex);&#10;    }&#10;&#10;    [Test]&#10;    public void IsAction_TrueForAction()&#10;    {&#10;        Action a = () =&gt; { };&#10;        Assert.That(AnonymousHelper.IsAction(a), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void IsAction_FalseForFunc()&#10;    {&#10;        Func&lt;int&gt; f = () =&gt; 1;&#10;        Assert.That(AnonymousHelper.IsAction(f), Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void IsFunc_TrueForFunc()&#10;    {&#10;        Func&lt;int&gt; f = () =&gt; 1;&#10;        Assert.That(AnonymousHelper.IsFunc(f), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void IsFunc_FalseForAction()&#10;    {&#10;        Action a = () =&gt; { };&#10;        Assert.That(AnonymousHelper.IsFunc(a), Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void GetGenericArguments_Delegate_ReturnsCorrectTypes()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        var args = AnonymousHelper.GetGenericArguments(del);&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(string) }));&#10;    }&#10;&#10;    [Test]&#10;    public void GetGenericArguments_Type_ReturnsCorrectTypes()&#10;    {&#10;        var args = AnonymousHelper.GetGenericArguments(typeof(Action&lt;int, string&gt;));&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(string) }));&#10;    }&#10;&#10;    [Test]&#10;    public void HasArgOfType_ReturnsTrueIfArgMatches()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        Assert.That(AnonymousHelper.HasArgOfType&lt;string&gt;(del), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void HasArgOfType_ReturnsFalseIfArgDoesNotMatch()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        Assert.That(AnonymousHelper.HasArgOfType&lt;double&gt;(del), Is.False);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousInvokersTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousInvokersTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousInvokers))]&#10;public class AnonymousInvokersTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;using System;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousInvokers))]&#10;public class AnonymousInvokersTest&#10;{&#10;    [Test]&#10;    public void GetActionInvoker_InvokesNormalAction()&#10;    {&#10;        int called = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; called = ctx + 1;&#10;        var anon = AnonymousValue.From(41);&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Reset);&#10;&#10;        Assert.That(called, Is.EqualTo(42));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(41)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvoker_InvokesMutatingAction()&#10;    {&#10;        Action&lt;ref int&gt; action = (ref int ctx) =&gt; ctx += 10;&#10;        var anon = AnonymousValue.From(5);&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Mutate);&#10;&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(15));&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvokerTArg_InvokesNormalActionWithArg()&#10;    {&#10;        int called = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; called = ctx + arg;&#10;        var anon = AnonymousValue.From(10);&#10;        int arg = 5;&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker&lt;int&gt;(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Reset, ref arg);&#10;&#10;        Assert.That(called, Is.EqualTo(15));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvokerTArg_InvokesMutatingActionWithArg()&#10;    {&#10;        ActionWithRefContext&lt;int, int&gt; action = (ref int ctx, int arg) =&gt; ctx += arg;&#10;        var anon = AnonymousValue.From(7);&#10;        int arg = 3;&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker&lt;int&gt;(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Mutate, ref arg);&#10;&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_InvokesNormalFunc()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx * 2;&#10;        var anon = AnonymousValue.From(21);&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Reset);&#10;&#10;        Assert.That(result, Is.EqualTo(42));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(21)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_InvokesMutatingFunc()&#10;    {&#10;        RefFunc&lt;int, int&gt; func = (ref int ctx) =&gt; ++ctx;&#10;        var anon = AnonymousValue.From(99);&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Mutate);&#10;&#10;        Assert.That(result, Is.EqualTo(100));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(100));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_InvokesNormalFuncWithArg()&#10;    {&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;        var anon = AnonymousValue.From(10);&#10;        int arg = 5;&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int, int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Reset, ref arg);&#10;&#10;        Assert.That(result, Is.EqualTo(15));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_InvokesMutatingFuncWithArg()&#10;    {&#10;        RefFunc&lt;int, int, int&gt; func = (ref int ctx, ref int arg) =&gt; ctx += arg;&#10;        var anon = AnonymousValue.From(3);&#10;        int arg = 4;&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int, int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Mutate, ref arg);&#10;&#10;        Assert.That(result, Is.EqualTo(7));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(7));&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvoker_ThrowsOnInvalidDelegate()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx;&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; AnonymousInvokers.GetActionInvoker(func));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_ThrowsOnInvalidReturnType()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx;&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; AnonymousInvokers.GetFuncInvoker&lt;string&gt;(func));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_ThrowsOnInvalidArgType()&#10;    {&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; AnonymousInvokers.GetFuncInvoker&lt;string, int&gt;(func));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousValueTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousValueTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousValue))]&#10;public class AnonymousValueTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousValue))]&#10;public class AnonymousValueTest&#10;{&#10;    [TestCase('a')]&#10;    [TestCase('Z')]&#10;    public void Char_Roundtrip(char value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;char&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;char&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(char)));&#10;    }&#10;&#10;    [TestCase(true)]&#10;    [TestCase(false)]&#10;    public void Bool_Roundtrip(bool value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;bool&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;bool&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(bool)));&#10;    }&#10;&#10;    [TestCase((byte)1)]&#10;    [TestCase(byte.MaxValue)]&#10;    public void Byte_Roundtrip(byte value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;byte&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;byte&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(byte)));&#10;    }&#10;&#10;    [TestCase((sbyte)-1)]&#10;    [TestCase(sbyte.MaxValue)]&#10;    public void SByte_Roundtrip(sbyte value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;sbyte&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;sbyte&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(sbyte)));&#10;    }&#10;&#10;    [TestCase((short)-123)]&#10;    [TestCase(short.MaxValue)]&#10;    public void Short_Roundtrip(short value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;short&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;short&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(short)));&#10;    }&#10;&#10;    [TestCase((ushort)123)]&#10;    [TestCase(ushort.MaxValue)]&#10;    public void UShort_Roundtrip(ushort value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;ushort&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;ushort&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(ushort)));&#10;    }&#10;&#10;    [TestCase(-123)]&#10;    [TestCase(int.MaxValue)]&#10;    public void Int_Roundtrip(int value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;int&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(int)));&#10;    }&#10;&#10;    [TestCase(uint.MaxValue)]&#10;    [TestCase(123u)]&#10;    public void UInt_Roundtrip(uint value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;uint&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;uint&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(uint)));&#10;    }&#10;&#10;    [TestCase(-123L)]&#10;    [TestCase(long.MaxValue)]&#10;    public void Long_Roundtrip(long value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;long&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;long&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(long)));&#10;    }&#10;&#10;    [TestCase(ulong.MaxValue)]&#10;    [TestCase(123UL)]&#10;    public void ULong_Roundtrip(ulong value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;ulong&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;ulong&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(ulong)));&#10;    }&#10;&#10;    [TestCase(1.23f)]&#10;    [TestCase(float.MaxValue)]&#10;    public void Float_Roundtrip(float value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;float&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;float&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(float)));&#10;    }&#10;&#10;    [TestCase(1.23)]&#10;    [TestCase(double.MaxValue)]&#10;    public void Double_Roundtrip(double value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;double&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;double&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(double)));&#10;    }&#10;&#10;    [TestCase(1.23)]&#10;    [TestCase(123456789.123456789)]&#10;    public void Decimal_Roundtrip(decimal value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;decimal&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;decimal&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(decimal)));&#10;    }&#10;&#10;    [Test]&#10;    public void Reference_Roundtrip()&#10;    {&#10;        var obj = new object();&#10;        var anon = AnonymousValue.From(obj);&#10;        Assert.That(anon.Is&lt;object&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;object&gt;(), Is.SameAs(obj));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(object)));&#10;    }&#10;&#10;    [Test]&#10;    public void Set_UpdatesValueAndType()&#10;    {&#10;        var anon = AnonymousValue.From(1);&#10;        anon.Set(2);&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(2));&#10;        anon.Set(&quot;hello&quot;);&#10;        Assert.That(anon.As&lt;string&gt;(), Is.EqualTo(&quot;hello&quot;));&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_WorksForSameValue()&#10;    {&#10;        var a = AnonymousValue.From(123);&#10;        var b = AnonymousValue.From(123);&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a == b, Is.True);&#10;        Assert.That(a != b, Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_WorksForDifferentValue()&#10;    {&#10;        var a = AnonymousValue.From(123);&#10;        var b = AnonymousValue.From(456);&#10;        Assert.That(a, Is.Not.EqualTo(b));&#10;        Assert.That(a == b, Is.False);&#10;        Assert.That(a != b, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void As_InvalidCast_Throws()&#10;    {&#10;        var anon = AnonymousValue.From(123);&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; anon.As&lt;string&gt;());&#10;    }&#10;&#10;    [Test]&#10;    public void Set_NullReference_Throws()&#10;    {&#10;        var anon = AnonymousValue.From(123);&#10;        Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; anon.Set&lt;object&gt;(null!));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/ResultTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/ResultTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(Result))]&#10;public class ResultTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(Result))]&#10;public class ResultTest&#10;{&#10;    [Test]&#10;    public void Result_Success_CreatesSuccessResult()&#10;    {&#10;        var result = Result.Success();&#10;        Assert.That(result.IsSuccess, Is.True);&#10;        Assert.That(result.Exception, Is.Null);&#10;        Assert.That((bool)result, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void Result_Failure_CreatesFailureResult()&#10;    {&#10;        var ex = new InvalidOperationException(&quot;fail&quot;);&#10;        var result = Result.Failure(ex);&#10;        Assert.That(result.IsSuccess, Is.False);&#10;        Assert.That(result.Exception, Is.EqualTo(ex));&#10;        Assert.That((bool)result, Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void ResultT_Success_CreatesSuccessResult()&#10;    {&#10;        var value = 42;&#10;        var result = Result&lt;int&gt;.Success(value);&#10;        Assert.That(result.IsSuccess, Is.True);&#10;        Assert.That(result.Value, Is.EqualTo(value));&#10;        Assert.That(result.Exception, Is.Null);&#10;        Assert.That((bool)result, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void ResultT_Failure_CreatesFailureResult()&#10;    {&#10;        var ex = new ArgumentException(&quot;fail&quot;);&#10;        var result = Result&lt;string&gt;.Failure(ex);&#10;        Assert.That(result.IsSuccess, Is.False);&#10;        Assert.That(result.Value, Is.Null);&#10;        Assert.That(result.Exception, Is.EqualTo(ex));&#10;        Assert.That((bool)result, Is.False);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Anonymous/AnonymousHelper.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Anonymous/AnonymousHelper.cs" />
              <option name="originalContent" value="using System.Collections.Concurrent;&#10;using System.Reflection;&#10;&#10;namespace Closures.Anonymous;&#10;&#10;/// &lt;summary&gt;&#10;/// Provides utility methods for working with anonymous closures.&#10;/// &lt;/summary&gt;&#10;public static class AnonymousHelper {&#10;    static readonly ConcurrentDictionary&lt;Type, Type&gt; s_closureTypeToInterfaceTypeMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, Type[]&gt; s_interfaceTypeToGenericArgumentsMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, Type[]&gt; s_delegateTypeToGenericArgumentsMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, MethodInfo&gt; s_delegateTypeToMethodInfoMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, ParameterInfo[]&gt; s_delegateTypeToParametersMap = new ();&#10;&#10;    static AnonymousHelper() {&#10;        ClosureManager.OnCacheClear += ClearCache;&#10;    }&#10;&#10;    public static void ClearCache() {&#10;        s_closureTypeToInterfaceTypeMap.Clear();&#10;        s_interfaceTypeToGenericArgumentsMap.Clear();&#10;        s_delegateTypeToGenericArgumentsMap.Clear();&#10;        s_delegateTypeToMethodInfoMap.Clear();&#10;        s_delegateTypeToParametersMap.Clear();&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the &lt;see cref=&quot;IClosure{TContext,TDelegate}&quot;/&gt; interface implemented by the specified closure type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TClosureType&quot;&gt;The closure type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The interface type implemented by the closure.&lt;/returns&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown if the type does not implement &lt;see cref=&quot;IClosure{TContext,TDelegate}&quot;/&gt;.&lt;/exception&gt;&#10;    public static Type GetInterfaceType&lt;TClosureType&gt;() where TClosureType : IClosure {&#10;        return s_closureTypeToInterfaceTypeMap.GetOrAdd(typeof(TClosureType), type =&gt; {&#10;            var interfaceType = type.GetInterfaces()&#10;                .FirstOrDefault(i =&gt; i.IsGenericType &amp;&amp; i.GetGenericTypeDefinition() == typeof(IClosure&lt;,&gt;));&#10;&#10;            if (interfaceType is null)&#10;                throw new InvalidOperationException(&#10;                    $&quot;The type {typeof(TClosureType).Name} does not implement IClosure&lt;&gt; interface.&quot;);&#10;&#10;            return interfaceType;&#10;        });&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the generic arguments of the specified closure interface type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;interfaceType&quot;&gt;The closure interface type.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetInterfaceGenericArguments(Type interfaceType) {&#10;        return s_interfaceTypeToGenericArgumentsMap.GetOrAdd(interfaceType, type =&gt; type.GetGenericArguments());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Determines if an anonymous closure can be converted to a strongly-typed closure.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TFrom&quot;&gt;The anonymous closure type.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TTo&quot;&gt;The strongly-typed closure type.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;closure&quot;&gt;The anonymous closure instance.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the conversion is possible; otherwise, false.&lt;/returns&gt;&#10;    public static bool CanConvert&lt;TFrom, TTo&gt;(TFrom closure) where TTo : IClosure where TFrom : IAnonymousClosure {&#10;        var anonymousContextType = closure.Context.GetUnderlyingType();&#10;        var anonymousDelegateType = closure.Delegate.GetType();&#10;        var conversionInterfaceType = GetInterfaceType&lt;TTo&gt;();&#10;        var genericArguments = GetInterfaceGenericArguments(conversionInterfaceType);&#10;        &#10;        return (genericArguments[0] == anonymousContextType || genericArguments[0] == typeof(AnonymousValue))&#10;               &amp;&amp; genericArguments[1] == anonymousDelegateType;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate can be invoked as a delegate of type &lt;typeparamref name=&quot;TDelegate&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegate&quot;&gt;The delegate to invoke including context&lt;/param&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type excluding context&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;True if the type arguments excluding the first one of the given delegate (TContext) match; Otherwise false&lt;/returns&gt;&#10;    public static bool InvokableAs&lt;TDelegate&gt;(Delegate @delegate) where TDelegate : Delegate {&#10;        if (IsAction(@delegate) != IsAction&lt;TDelegate&gt;())&#10;            return false;&#10;        &#10;        var parameters = GetParameters(@delegate);&#10;        var expectedParameters = GetParameters&lt;TDelegate&gt;();&#10;        &#10;        if (parameters.Length - 1 != expectedParameters.Length)&#10;            return false;&#10;        &#10;        for (var i = 0; i &lt; parameters.Length - 1; i++) {&#10;            if (parameters[i + 1].ParameterType != expectedParameters[i].ParameterType) {&#10;                return false;&#10;            }&#10;        }&#10;        &#10;        return true;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether an exception should be thrown based on the specified exception handling policy.&#10;    /// Used in anonymous closure TryInvoke methods to decide whether to propagate exceptions or handle them.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception to evaluate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;policy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the exception should be thrown; otherwise, false.&lt;/returns&gt;&#10;    public static bool ShouldThrow(Exception ex, ExceptionHandlingPolicy policy) {&#10;        return policy switch {&#10;            ExceptionHandlingPolicy.HandleExpected =&gt; &#10;                ex is not (InvalidOperationException or InvalidCastException or ArgumentException),&#10;            ExceptionHandlingPolicy.HandleAll =&gt; true,&#10;            ExceptionHandlingPolicy.HandleNone =&gt; false,&#10;            _ =&gt; throw new ArgumentOutOfRangeException(nameof(policy), policy, null)&#10;        };&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate is an action (returns void).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate is an action; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsAction(Delegate del) =&gt; del.Method.ReturnType == typeof(void);&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type is an action (returns void).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type to check.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;True if the delegate type is an action; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsAction&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        return GetInvokeMethod&lt;TDelegate&gt;().ReturnType == typeof(void);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type is an action (returns void).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate type is an action; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsAction(Type delegateType) {&#10;        return GetInvokeMethod(delegateType).ReturnType == typeof(void);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate is a function (returns a value).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate is a function; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsFunc(Delegate del) =&gt; del.Method.ReturnType != typeof(void);&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type is a function (returns a value).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type to check.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;True if the delegate type is a function; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsFunc&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        return GetInvokeMethod&lt;TDelegate&gt;() != typeof(void);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type is a function (returns a value).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate type is a function; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsFunc(Type delegateType) {&#10;        return GetInvokeMethod(delegateType).ReturnType != typeof(void);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the generic argument types of the specified delegate instance.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegate&quot;&gt;The delegate instance.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetGenericArguments(Delegate @delegate) {&#10;        return GetGenericArguments(@delegate.GetType());&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Gets the generic argument types of the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetGenericArguments(Type delegateType) {&#10;        return s_delegateTypeToGenericArgumentsMap.GetOrAdd(delegateType, type =&gt; type.GetGenericArguments());&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Gets the generic argument types of the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetGenericArguments&lt;TDelegate&gt;() {&#10;        return s_delegateTypeToGenericArgumentsMap.GetOrAdd(typeof(TDelegate), type =&gt; type.GetGenericArguments());&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the parameter information for the specified delegate instance.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegate&quot;&gt;The delegate instance.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of &lt;see cref=&quot;ParameterInfo&quot;/&gt; objects describing the parameters of the delegate's Invoke method.&lt;/returns&gt;&#10;    public static ParameterInfo[] GetParameters(Delegate @delegate) {&#10;        return s_delegateTypeToParametersMap.GetOrAdd(@delegate.GetType(), type =&gt; GetInvokeMethod(type).GetParameters());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the parameter information for the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of &lt;see cref=&quot;ParameterInfo&quot;/&gt; objects describing the parameters of the delegate's Invoke method.&lt;/returns&gt;&#10;    public static ParameterInfo[] GetParameters(Type delegateType) {&#10;        return s_delegateTypeToParametersMap.GetOrAdd(delegateType, type =&gt; GetInvokeMethod(type).GetParameters());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the parameter information for the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;An array of &lt;see cref=&quot;ParameterInfo&quot;/&gt; objects describing the parameters of the delegate's Invoke method.&lt;/returns&gt;&#10;    public static ParameterInfo[] GetParameters&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        return s_delegateTypeToParametersMap.GetOrAdd(typeof(TDelegate), type =&gt; GetInvokeMethod(type).GetParameters());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the Invoke method for the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type.&lt;/param&gt;&#10;    /// &lt;returns&gt;The &lt;see cref=&quot;MethodInfo&quot;/&gt; representing the Invoke method.&lt;/returns&gt;&#10;    public static MethodInfo GetInvokeMethod(Type delegateType) {&#10;        return s_delegateTypeToMethodInfoMap.GetOrAdd(delegateType, &#10;            type =&gt; type.GetMethod(&quot;Invoke&quot;) ??&#10;                    throw new InvalidOperationException($&quot;The type {type.Name} does not have an 'Invoke' method.&quot;)&#10;        );&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the Invoke method for the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The &lt;see cref=&quot;MethodInfo&quot;/&gt; representing the Invoke method.&lt;/returns&gt;&#10;    public static MethodInfo GetInvokeMethod&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        return s_delegateTypeToMethodInfoMap.GetOrAdd(typeof(TDelegate), &#10;            type =&gt; type.GetMethod(&quot;Invoke&quot;) ??&#10;                    throw new InvalidOperationException($&quot;The type {type.Name} does not have an 'Invoke' method.&quot;)&#10;        );&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate has a TArg.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate has an argument; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArg(Delegate del) { &#10;        var genericArguments = GetGenericArguments(del);&#10;        return IsAction(del) ? genericArguments.Length &gt; 1 : genericArguments.Length &gt; 2;&#10;    }&#10;    public static bool HasArg(Type delegateType) { &#10;        var genericArguments = GetGenericArguments(delegateType);&#10;        return IsAction(delegateType) ? genericArguments.Length &gt; 1 : genericArguments.Length &gt; 2;&#10;    }&#10;    public static bool HasArg&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        var genericArguments = GetGenericArguments&lt;TDelegate&gt;();&#10;        return IsAction&lt;TDelegate&gt;() ? genericArguments.Length &gt; 1 : genericArguments.Length &gt; 2;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate has an argument of the given type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The argument type to check for.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate has an argument of the specified type; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArgOfType&lt;TArg&gt;(Delegate del) {&#10;        var genericArguments = GetGenericArguments(del);&#10;        return IsAction(del) &#10;            ? genericArguments.Length &gt; 1 &amp;&amp; genericArguments[1] == typeof(TArg) &#10;            : genericArguments.Length &gt; 2 &amp;&amp; genericArguments[1] == typeof(TArg);&#10;    }&#10;    public static bool HasArgOfType&lt;TArg&gt;(Type delegateType) {&#10;        var genericArguments = GetGenericArguments(delegateType);&#10;        return IsAction(delegateType) &#10;            ? genericArguments.Length &gt; 1 &amp;&amp; genericArguments[1] == typeof(TArg) &#10;            : genericArguments.Length &gt; 2 &amp;&amp; genericArguments[1] == typeof(TArg);&#10;    }&#10;    public static bool HasArgOfType&lt;TArg, TDelegate&gt;() where TDelegate : Delegate {&#10;        var genericArguments = GetGenericArguments&lt;TDelegate&gt;();&#10;        return IsAction&lt;TDelegate&gt;()&#10;            ? genericArguments.Length &gt; 1 &amp;&amp; genericArguments[1] == typeof(TArg)&#10;            : genericArguments.Length &gt; 2 &amp;&amp; genericArguments[1] == typeof(TArg);&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections.Concurrent;&#10;using System.Reflection;&#10;&#10;namespace Closures.Anonymous;&#10;&#10;/// &lt;summary&gt;&#10;/// Provides utility methods for working with anonymous closures.&#10;/// &lt;/summary&gt;&#10;public static class AnonymousHelper {&#10;    static readonly ConcurrentDictionary&lt;Type, Type&gt; s_closureTypeToInterfaceTypeMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, Type[]&gt; s_interfaceTypeToGenericArgumentsMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, Type[]&gt; s_delegateTypeToGenericArgumentsMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, MethodInfo&gt; s_delegateTypeToMethodInfoMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, ParameterInfo[]&gt; s_delegateTypeToParametersMap = new ();&#10;&#10;    static AnonymousHelper() {&#10;        ClosureManager.OnCacheClear += ClearCache;&#10;    }&#10;&#10;    public static void ClearCache() {&#10;        s_closureTypeToInterfaceTypeMap.Clear();&#10;        s_interfaceTypeToGenericArgumentsMap.Clear();&#10;        s_delegateTypeToGenericArgumentsMap.Clear();&#10;        s_delegateTypeToMethodInfoMap.Clear();&#10;        s_delegateTypeToParametersMap.Clear();&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the &lt;see cref=&quot;IClosure{TContext,TDelegate}&quot;/&gt; interface implemented by the specified closure type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TClosureType&quot;&gt;The closure type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The interface type implemented by the closure.&lt;/returns&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown if the type does not implement &lt;see cref=&quot;IClosure{TContext,TDelegate}&quot;/&gt;.&lt;/exception&gt;&#10;    public static Type GetInterfaceType&lt;TClosureType&gt;() where TClosureType : IClosure {&#10;        return s_closureTypeToInterfaceTypeMap.GetOrAdd(typeof(TClosureType), type =&gt; {&#10;            var interfaceType = type.GetInterfaces()&#10;                .FirstOrDefault(i =&gt; i.IsGenericType &amp;&amp; i.GetGenericTypeDefinition() == typeof(IClosure&lt;,&gt;));&#10;&#10;            if (interfaceType is null)&#10;                throw new InvalidOperationException(&#10;                    $&quot;The type {typeof(TClosureType).Name} does not implement IClosure&lt;&gt; interface.&quot;);&#10;&#10;            return interfaceType;&#10;        });&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the generic arguments of the specified closure interface type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;interfaceType&quot;&gt;The closure interface type.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetInterfaceGenericArguments(Type interfaceType) {&#10;        return s_interfaceTypeToGenericArgumentsMap.GetOrAdd(interfaceType, type =&gt; type.GetGenericArguments());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Determines if an anonymous closure can be converted to a strongly-typed closure.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TFrom&quot;&gt;The anonymous closure type.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TTo&quot;&gt;The strongly-typed closure type.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;closure&quot;&gt;The anonymous closure instance.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the conversion is possible; otherwise, false.&lt;/returns&gt;&#10;    public static bool CanConvert&lt;TFrom, TTo&gt;(TFrom closure) where TTo : IClosure where TFrom : IAnonymousClosure {&#10;        var anonymousContextType = closure.Context.GetUnderlyingType();&#10;        var anonymousDelegateType = closure.Delegate.GetType();&#10;        var conversionInterfaceType = GetInterfaceType&lt;TTo&gt;();&#10;        var genericArguments = GetInterfaceGenericArguments(conversionInterfaceType);&#10;        &#10;        return (genericArguments[0] == anonymousContextType || genericArguments[0] == typeof(AnonymousValue))&#10;               &amp;&amp; genericArguments[1] == anonymousDelegateType;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate can be invoked as a delegate of type &lt;typeparamref name=&quot;TDelegate&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegate&quot;&gt;The delegate to invoke including context&lt;/param&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type excluding context&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;True if the type arguments excluding the first one of the given delegate (TContext) match; Otherwise false&lt;/returns&gt;&#10;    public static bool InvokableAs&lt;TDelegate&gt;(Delegate @delegate) where TDelegate : Delegate {&#10;        if (IsAction(@delegate) != IsAction&lt;TDelegate&gt;())&#10;            return false;&#10;        &#10;        var parameters = GetParameters(@delegate);&#10;        var expectedParameters = GetParameters&lt;TDelegate&gt;();&#10;        &#10;        if (parameters.Length - 1 != expectedParameters.Length)&#10;            return false;&#10;        &#10;        for (var i = 0; i &lt; parameters.Length - 1; i++) {&#10;            if (parameters[i + 1].ParameterType != expectedParameters[i].ParameterType) {&#10;                return false;&#10;            }&#10;        }&#10;        &#10;        return true;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether an exception should be thrown based on the specified exception handling policy.&#10;    /// Used in anonymous closure TryInvoke methods to decide whether to propagate exceptions or handle them.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception to evaluate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;policy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the exception should be thrown; otherwise, false.&lt;/returns&gt;&#10;    public static bool ShouldThrow(Exception ex, ExceptionHandlingPolicy policy) {&#10;        return policy switch {&#10;            ExceptionHandlingPolicy.HandleExpected =&gt; &#10;                ex is not (InvalidOperationException or InvalidCastException or ArgumentException),&#10;            ExceptionHandlingPolicy.HandleAll =&gt; true,&#10;            ExceptionHandlingPolicy.HandleNone =&gt; false,&#10;            _ =&gt; throw new ArgumentOutOfRangeException(nameof(policy), policy, null)&#10;        };&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate is an action (returns void).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate is an action; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsAction(Delegate del) =&gt; del.Method.ReturnType == typeof(void);&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type is an action (returns void).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type to check.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;True if the delegate type is an action; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsAction&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        return GetInvokeMethod&lt;TDelegate&gt;().ReturnType == typeof(void);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type is an action (returns void).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate type is an action; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsAction(Type delegateType) {&#10;        return GetInvokeMethod(delegateType).ReturnType == typeof(void);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate is a function (returns a value).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate is a function; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsFunc(Delegate del) =&gt; del.Method.ReturnType != typeof(void);&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type is a function (returns a value).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type to check.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;True if the delegate type is a function; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsFunc&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        return GetInvokeMethod&lt;TDelegate&gt;() != typeof(void);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type is a function (returns a value).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate type is a function; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsFunc(Type delegateType) {&#10;        return GetInvokeMethod(delegateType).ReturnType != typeof(void);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the generic argument types of the specified delegate instance.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegate&quot;&gt;The delegate instance.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetGenericArguments(Delegate @delegate) {&#10;        return GetGenericArguments(@delegate.GetType());&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Gets the generic argument types of the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetGenericArguments(Type delegateType) {&#10;        return s_delegateTypeToGenericArgumentsMap.GetOrAdd(delegateType, type =&gt; type.GetGenericArguments());&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Gets the generic argument types of the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetGenericArguments&lt;TDelegate&gt;() {&#10;        return s_delegateTypeToGenericArgumentsMap.GetOrAdd(typeof(TDelegate), type =&gt; type.GetGenericArguments());&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the parameter information for the specified delegate instance.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegate&quot;&gt;The delegate instance.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of &lt;see cref=&quot;ParameterInfo&quot;/&gt; objects describing the parameters of the delegate's Invoke method.&lt;/returns&gt;&#10;    public static ParameterInfo[] GetParameters(Delegate @delegate) {&#10;        return s_delegateTypeToParametersMap.GetOrAdd(@delegate.GetType(), type =&gt; GetInvokeMethod(type).GetParameters());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the parameter information for the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of &lt;see cref=&quot;ParameterInfo&quot;/&gt; objects describing the parameters of the delegate's Invoke method.&lt;/returns&gt;&#10;    public static ParameterInfo[] GetParameters(Type delegateType) {&#10;        return s_delegateTypeToParametersMap.GetOrAdd(delegateType, type =&gt; GetInvokeMethod(type).GetParameters());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the parameter information for the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;An array of &lt;see cref=&quot;ParameterInfo&quot;/&gt; objects describing the parameters of the delegate's Invoke method.&lt;/returns&gt;&#10;    public static ParameterInfo[] GetParameters&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        return s_delegateTypeToParametersMap.GetOrAdd(typeof(TDelegate), type =&gt; GetInvokeMethod(type).GetParameters());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the Invoke method for the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type.&lt;/param&gt;&#10;    /// &lt;returns&gt;The &lt;see cref=&quot;MethodInfo&quot;/&gt; representing the Invoke method.&lt;/returns&gt;&#10;    public static MethodInfo GetInvokeMethod(Type delegateType) {&#10;        return s_delegateTypeToMethodInfoMap.GetOrAdd(delegateType, &#10;            type =&gt; type.GetMethod(&quot;Invoke&quot;) ??&#10;                    throw new InvalidOperationException($&quot;The type {type.Name} does not have an 'Invoke' method.&quot;)&#10;        );&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the Invoke method for the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The &lt;see cref=&quot;MethodInfo&quot;/&gt; representing the Invoke method.&lt;/returns&gt;&#10;    public static MethodInfo GetInvokeMethod&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        return s_delegateTypeToMethodInfoMap.GetOrAdd(typeof(TDelegate), &#10;            type =&gt; type.GetMethod(&quot;Invoke&quot;) ??&#10;                    throw new InvalidOperationException($&quot;The type {type.Name} does not have an 'Invoke' method.&quot;)&#10;        );&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate has a TArg.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate has an argument; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArg(Delegate del) { &#10;        var genericArguments = GetGenericArguments(del);&#10;        return IsAction(del) ? genericArguments.Length &gt; 1 : genericArguments.Length &gt; 2;&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type has an argument.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate type has an argument; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArg(Type delegateType) { &#10;        var genericArguments = GetGenericArguments(delegateType);&#10;        return IsAction(delegateType) ? genericArguments.Length &gt; 1 : genericArguments.Length &gt; 2;&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type has an argument.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type to check.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;True if the delegate type has an argument; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArg&lt;TDelegate&gt;() where TDelegate : Delegate {&#10;        var genericArguments = GetGenericArguments&lt;TDelegate&gt;();&#10;        return IsAction&lt;TDelegate&gt;() ? genericArguments.Length &gt; 1 : genericArguments.Length &gt; 2;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type has an argument of the given type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The argument type to check for.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate type has an argument of the specified type; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArgOfType&lt;TArg&gt;(Type delegateType) {&#10;        var genericArguments = GetGenericArguments(delegateType);&#10;        return IsAction(delegateType) &#10;            ? genericArguments.Length &gt; 1 &amp;&amp; genericArguments[1] == typeof(TArg) &#10;            : genericArguments.Length &gt; 2 &amp;&amp; genericArguments[1] == typeof(TArg);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate type has an argument of the given type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The argument type to check for.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The delegate type to check.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;True if the delegate type has an argument of the specified type; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArgOfType&lt;TArg, TDelegate&gt;() where TDelegate : Delegate {&#10;        var genericArguments = GetGenericArguments&lt;TDelegate&gt;();&#10;        return IsAction&lt;TDelegate&gt;()&#10;            ? genericArguments.Length &gt; 1 &amp;&amp; genericArguments[1] == typeof(TArg)&#10;            : genericArguments.Length &gt; 2 &amp;&amp; genericArguments[1] == typeof(TArg);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Result.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Result.cs" />
              <option name="updatedContent" value="&#10;/// &lt;summary&gt;&#10;/// Represents the result of an operation, indicating success or failure and an optional exception.&#10;/// &lt;/summary&gt;&#10;public readonly record struct Result {&#10;    /// &lt;summary&gt;&#10;    /// Indicates whether the operation was successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly bool IsSuccess;&#10;    /// &lt;summary&gt;&#10;    /// The exception associated with a failed operation, or &lt;c&gt;null&lt;/c&gt; if successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly Exception? Exception;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Implicitly converts the result to a boolean indicating success.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;result&quot;&gt;The result to convert.&lt;/param&gt;&#10;    public static implicit operator bool(Result result) =&gt; result.IsSuccess;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;Result&quot;/&gt; struct.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;isSuccess&quot;&gt;Whether the operation was successful.&lt;/param&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception if the operation failed, or &lt;c&gt;null&lt;/c&gt; if successful.&lt;/param&gt;&#10;    Result(bool isSuccess, Exception? ex = null) {&#10;        IsSuccess = isSuccess;&#10;        Exception = ex;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a successful result.&#10;    /// &lt;/summary&gt;&#10;    public static Result Success() =&gt; new(true);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a failed result with the specified exception.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception representing the failure.&lt;/param&gt;&#10;    public static Result Failure(Exception ex) =&gt; new(false, ex);&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Represents the result of an operation that returns a value, indicating success or failure, the value, and an optional exception.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;T&quot;&gt;The type of the value returned by the operation.&lt;/typeparam&gt;&#10;public readonly record struct Result&lt;T&gt; {&#10;    /// &lt;summary&gt;&#10;    /// Indicates whether the operation was successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly bool IsSuccess;&#10;    /// &lt;summary&gt;&#10;    /// The value returned by the operation if successful, or &lt;c&gt;default&lt;/c&gt; if failed.&#10;    /// &lt;/summary&gt;&#10;    public readonly T? Value;&#10;    /// &lt;summary&gt;&#10;    /// The exception associated with a failed operation, or &lt;c&gt;null&lt;/c&gt; if successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly Exception? Exception;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Implicitly converts the result to a boolean indicating success.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;result&quot;&gt;The result to convert.&lt;/param&gt;&#10;    public static implicit operator bool(Result&lt;T&gt; result) =&gt; result.IsSuccess;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;Result{T}&quot;/&gt; struct.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;isSuccess&quot;&gt;Whether the operation was successful.&lt;/param&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value returned by the operation, or &lt;c&gt;default&lt;/c&gt; if failed.&lt;/param&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception if the operation failed, or &lt;c&gt;null&lt;/c&gt; if successful.&lt;/param&gt;&#10;    Result(bool isSuccess, T? value = default, Exception? ex = null) {&#10;        IsSuccess = isSuccess;&#10;        Value = value;&#10;        Exception = ex;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a successful result with the specified value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value returned by the operation.&lt;/param&gt;&#10;    public static Result&lt;T&gt; Success(T value) =&gt; new(true, value);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a failed result with the specified exception.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception representing the failure.&lt;/param&gt;&#10;    public static Result&lt;T&gt; Failure(Exception ex) =&gt; new(false, default, ex);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="# Closures&#10;Closure structs that capture a context and a delegate that is invoked with the given context.&#10;&#10;```csharp&#10;using Closures;&#10;&#10;// Captures 100 as context and prints it when invoked&#10;var closure = Closure.Action(100, &#10;    (context) =&gt; Console.WriteLine($&quot;Captured context {context})&quot;);&#10;    &#10;closure.Invoke(); // Output: Captured context 100&#10;```&#10;## Installation&#10;You can install the Closures library via NuGet Package Manager:&#10;&#10;```bash&#10;Install-Package Closures&#10;```&#10;Or by using the .NET CLI:&#10;&#10;```bash&#10;dotnet add package Closures&#10;```&#10;&#10;Performance benchmarks of the code from the Why? section using closure structs vs capturing variables&#10;in a lambda expression shows significant improvements in execution time and memory allocation.&#10;&#10;### Benchmark Results&#10;&#10;| Method        |      Mean |     Error |    StdDev | Allocated |&#10;|---------------|----------:|----------:|----------:|----------:|&#10;| Action        | 6.7512 ns | 0.0819 ns | 0.0726 ns |      88 B |&#10;| ClosureAction | 0.0103 ns | 0.0046 ns | 0.0043 ns |         - |&#10;&#10;With the benchmark results we can see that using closures is significantly faster than using regular actions or functions that capture variables in a lambda expression.&#10;&#10;The closure struct has a negligible allocation overhead compared to the action that captures variables in a lambda expression.&#10;This is due to the lambda expressions having to box the captured variables and allocate them on the heap,&#10;while the closure struct captures the context by value and does not require heap allocation.&#10;&#10;On top of this since the lambda is capturing the variable it has to allocate a new delegate instance every time it is created&#10;while the closure struct allows for a stateless delegates making it a static method behind the scenes.&#10;&#10;### Table of Contents&#10;- [Basic Closures](#basic-closures)&#10;- [Mutating Closures](#mutating-closures)&#10;- [Ref Closures](#ref-closures)&#10;- [Anonymous Closures](#anonymous-closures)&#10;- [Custom Closure](#custom-closure)&#10;- [Converting to Delegates](#converting-to-delegates)&#10;- [Closure Types](#closure-types)&#10;&#10;## Usage&#10;To use the closures, simply create an instance of the desired closure type using the `Closure.Action` or `Closure.Func` methods, &#10;passing in the context and the delegate to be invoked. The closures can then be invoked like a delegate.&#10;&#10;### Basic closures&#10;- `ClosureAction&lt;TContext&gt;` that captures a string context.&#10;- `ClosureFunc&lt;TContext, TReturn&gt;` that captures an int context and returns a doubled value.&#10;&#10;```csharp&#10;// Example of ClosureAction&#10;var closureAction = Closure.Action(&quot;captured context&quot;, &#10;    (string context) =&gt; Console.WriteLine($&quot;Action with context - {context}&quot;));&#10;&#10;closureAction.Invoke(); // Output: Action with context - captured context&#10;&#10;// Example of ClosureFunc&#10;var closureFunc = Closure.Func(10, (int context) =&gt; context * 2);&#10;Console.WriteLine(closureFunc.Invoke()); // Output: 20&#10;```&#10;&#10;### Passing an argument&#10;Closures can also take in an argument when invoking them.&#10;The context is always passed as the first parameter, followed by the argument.&#10;- `ClosureAction&lt;TContext, TArg&gt;` that captures an int context and is called with an int argument.&#10;- `ClosureFunc&lt;TContext, TArg, TResult&gt;` that captures an int context, is called with an int argument and returns the sum of the context and argument.&#10;&#10;```csharp &#10;// Example of ClosureAction with an argument&#10;var closureActionWithArg = Closure.Action(10, (int context, int arg) =&gt; &#10;    Console.WriteLine($&quot;Context: {context}, Arg: {arg}&quot;));&#10;&#10;closureActionWithArg.Invoke(5); // Output: Context: 10, Arg: 5&#10;    &#10;// Example of ClosureFunc with an argument&#10;var closureFuncWithArg = Closure.Func(10, (int context, int arg) =&gt; context + arg);&#10;Console.WriteLine(closureFuncWithArg.Invoke(5)); // Output: 15&#10;```&#10;&#10;Arguments can also be passed as `ref`, allowing the closure to modify the argument value.&#10;- `ClosureRefAction&lt;TContext, TArg&gt;` that captures an int context and is called with a ref int argument which is set to the value of context.&#10;- `ClosureRefFunc&lt;TContext, TArg, TResult&gt;` that captures an int context, is called with a ref int argument which is set to the value of context and returns the sum of the context and argument.&#10;&#10;```csharp&#10;// Example of ClosureAction with a ref argument&#10;int arg = 5;&#10;var closureActionWithRefArg = Closure.RefAction(10, (int context, ref int arg) =&gt; arg = context);&#10;closureActionWithRefArg.Invoke(ref arg);&#10;Console.WriteLine(arg); // Output: 10&#10;    &#10;// Example of ClosureFunc with a ref argument&#10;var funcArg = 5;&#10;var closureFuncWithRefArg = Closure.RefFunc(10, (int context, ref int arg) =&gt; {&#10;    var sum = context + arg;&#10;    arg = context;&#10;    return sum;&#10;});&#10;var returnValue = closureFuncWithRefArg.Invoke(ref funcArg);&#10;Console.WriteLine(returnValue); // Output: 15&#10;Console.WriteLine(funcArg); // Output: 10&#10;```&#10;&#10;### Mutating closures&#10;Mutating closures allow you to modify the captured context within the delegate. &#10;They are useful when you want to invoke the closure multiple times with the context being modified each time.&#10;&#10;- `MutatingClosureAction&lt;TContext&gt;` that captures a mutable context.&#10;- `MutatingClosureFunc&lt;TContext, TReturn&gt;` that captures a mutable context and returns the sum of modifications.&#10;&#10;```csharp&#10;// Example of MutatingClosureAction&#10;var mutatingClosureAction = MutatingClosure.Action(10, (ref int context) =&gt; {&#10;    Console.WriteLine(context)&#10;    context += 5&#10;});&#10;mutatingClosureAction.Invoke(); // Output: 10&#10;mutatingClosureAction.Invoke(); // Output: 15&#10;&#10;// Example of MutatingClosureFunc&#10;var mutatingClosureFunc = Closure.Func(20, (ref int context) =&gt; context *= 2);&#10;Console.WriteLine(mutatingClosureFunc.Invoke()); // Output: 40&#10;Console.WriteLine(mutatingClosureFunc.Invoke()); // Output: 80&#10;```&#10;&#10;### Ref closures&#10;Ref closures work similarly to mutating closures with the difference being that &#10;they are ref structs that capture a reference to a context variable, allowing it to modify the original variable.&#10;&#10;- `RefActionClosure&lt;TContext&gt;` that captures a reference to a mutable context.&#10;- `RefFuncClosure&lt;TContext, TReturn&gt;` that captures a reference to a mutable context and returns a modified value.&#10;&#10;```csharp&#10;// Example of RefActionClosure&#10;var refContext = 10;&#10;var refClosureAction = RefClosure.Action(ref refContext, (ref int context) =&gt; {&#10;    Console.WriteLine(context);&#10;    context += 10;&#10;});&#10;&#10;refClosureAction.Invoke(); // Output: 10&#10;Console.WriteLine(refContext); // Output: 20&#10;&#10;refClosureAction.Invoke(); // Output: 20&#10;Console.WriteLine(refContext); // Output: 30&#10;&#10;// Example of RefFuncClosure&#10;var refFuncContext = 10;&#10;var refClosureFunc = RefClosure.Func(ref refFuncContext, (ref int context) =&gt; {&#10;    context *= 2;&#10;    return context * 2;&#10;});&#10;&#10;Console.WriteLine(refClosureFunc.Invoke()); // Output: 40&#10;Console.WriteLine(refFuncContext); // Output: 20&#10;&#10;Console.WriteLine(refClosureFunc.Invoke()); // Output: 80&#10;Console.WriteLine(refFuncContext); // Output: 40&#10;```&#10;&#10;### Anonymous closures&#10;&#10;Anonymous closures provide a type-erased, flexible way to store and invoke closures (delegates with captured context) without knowing the exact context or delegate type at compile time. They are useful when you need to work with closures in a generic or dynamic fashion, such as storing heterogeneous closures in collections, passing them through APIs, or bridging between different closure types.&#10;&#10;Anonymous closures encapsulate:&#10;- A delegate (action or function, with or without arguments)&#10;- An `AnonymousValue` context (a type-erased container for any value or reference type)&#10;- A `MutatingBehaviour` (controls whether the context is mutated or reset after invocation)&#10;&#10;#### Types&#10;&#10;- `AnonymousClosure`: The core type-erased closure struct. It can represent any closure (action or function, with or without arguments or return value). It exposes generic `Invoke` and `TryInvoke` methods for all supported delegate signatures.&#10;- `AnonymousClosureAction`: Represents an anonymous closure for a delegate with no arguments and no return value (action).&#10;- `AnonymousClosureAction&lt;TArg&gt;`: Represents an anonymous closure for a delegate with a single argument and no return value.&#10;- `AnonymousClosureFunc&lt;TReturn&gt;`: Represents an anonymous closure for a delegate with no arguments and a return value.&#10;- `AnonymousClosureFunc&lt;TArg, TReturn&gt;`: Represents an anonymous closure for a delegate with a single argument and a return value.&#10;&#10;All anonymous closure types implement the `IAnonymousClosure` interface, which provides access to the context, delegate, and mutating behaviour, as well as:&#10;- `Is&lt;TClosureType&gt;()`: Checks if the anonymous closure can be converted to a specific strongly-typed closure type.&#10;- `InvokableAs&lt;TDelegate&gt;()`: Checks if the anonymous closure can be invoked as if it was a delegate of type `TDelegate`.&#10;&#10;#### Mutating Behaviour&#10;&#10;The `MutatingBehaviour` enum controls whether the context is mutated (`Mutate`) or reset (`Reset`) after invocation. This allows you to choose between closures that modify their captured context (like mutating closures) and those that do not.&#10;&#10;#### Usage&#10;&#10;You can create anonymous closures using the static factory methods on `AnonymousClosure`, such as:&#10;&#10;```csharp&#10;// Create an anonymous action closure&#10;var anonAction = AnonymousClosure.Action(AnonymousValue.From(42), (int ctx) =&gt; Console.WriteLine(ctx));&#10;&#10;// Create an anonymous function closure with a return value&#10;var anonFunc = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(&quot;hello&quot;), (string ctx) =&gt; ctx.Length);&#10;&#10;// Create an anonymous closure from a strongly-typed closure&#10;var closure = Closure.Action(100, (int ctx) =&gt; Console.WriteLine(ctx));&#10;AnonymousClosure anon = closure.AsAnonymous();&#10;```&#10;&#10;You can invoke anonymous closures using their `Invoke` or `TryInvoke` methods. The `TryInvoke` methods return a `Result` or `Result&lt;T&gt;` indicating success or failure, and allow you to specify an `ExceptionHandlingPolicy` to control how exceptions are handled.&#10;&#10;```csharp&#10;anonAction.Invoke(); // Invokes the action&#10;var result = anonFunc.TryInvoke(); // Returns Result&lt;int&gt;&#10;if (result.IsSuccess) {&#10;    Console.WriteLine(result.Value);&#10;}&#10;```&#10;&#10;#### Type Checking and Invocation&#10;&#10;You can use `Is&lt;TClosureType&gt;()` to check if an anonymous closure can be converted to a specific strongly-typed closure type, and then convert it back using the appropriate extension method:&#10;&#10;You can use `InvokableAs&lt;TDelegate&gt;()` to check if an anonymous closure can be invoked as if it was a specific delegate type.&#10;&#10;Anonymous closures can be converted back to strongly-typed closures (if the types match) using extension methods such as `AsClosureAction&lt;TContext&gt;()` or `AsClosureFunc&lt;TContext, TResult&gt;()`.&#10;&#10;Example:&#10;&#10;```csharp&#10;// Store different closures in a single list&#10;var list = new List&lt;AnonymousClosure&gt;();&#10;list.Add(Closure.Action(1, (int ctx) =&gt; Console.WriteLine(ctx)).AsAnonymous());&#10;list.Add(Closure.Func(&quot;abc&quot;, (string ctx) =&gt; ctx.Length).AsAnonymous());&#10;&#10;foreach (var anon in list) {&#10;    if (anon.InvokableAs&lt;Func&lt;int&gt;&gt;())&#10;        Console.WriteLine(anon.Invoke&lt;int&gt;());&#10;    else if (anon.InvokableAs&lt;Action&gt;())&#10;        anon.Invoke();&#10;}&#10;&#10;// Example: Checking type and converting back to a strongly-typed closure&#10;var anonClosure = Closure.Func(&quot;hello&quot;, (string ctx) =&gt; ctx.Length).AsAnonymous();&#10;if (anonClosure.Is&lt;ClosureFunc&lt;string, int&gt;&gt;()) {&#10;    var typed = anonClosure.AsClosureFunc&lt;string, int&gt;();&#10;    Console.WriteLine(typed.Invoke()); // Output: 5&#10;}&#10;```&#10;&#10;#### Remarks&#10;&#10;- Anonymous closures are type-erased and do not enforce type safety at compile time. You must ensure that the delegate and context types are compatible when converting or invoking.&#10;- Useful for storing closures of different types in a single collection, or for APIs that need to accept arbitrary closures.&#10;&#10;However, with the flexibility comes some performance overhead compared to strongly-typed closures, so use them judiciously in performance-critical scenarios.&#10;&#10;| Method                    |       Mean |     Error |    StdDev | Allocated |&#10;|---------------------------|-----------:|----------:|----------:|----------:|&#10;| Action                    |  4.7119 ns | 0.0502 ns | 0.0445 ns |      88 B |&#10;| ClosureAction             |  0.0221 ns | 0.0044 ns | 0.0039 ns |         - |&#10;| ClosureAction_AsAnonymous | 25.8292 ns | 0.0883 ns | 0.0783 ns |         - |&#10;&#10;### Custom Closure&#10;You can use `Closure.Custom&lt;TContext, TDelegate&gt;(TContext, TDelegate)` to create a closure with a custom delegate type.&#10;This allows you to define your own delegate type and use it with the closure.&#10;However, you must call the delegate manually using the `Delegate` property and pass the context and arguments as needed.&#10;Essentially this just wraps the delegate and context in a struct, allowing you to use any delegate type with the closure.&#10;```csharp&#10;delegate void CustomDelegate(int context, string message, ref int mutatableInt);&#10;&#10;var customClosure = Closure.Custom&lt;int, CustomDelegate&gt;(100, &#10;    (int context, string message, ref int mutatableInt) =&gt; {&#10;    Console.WriteLine($&quot;Context: {context}, message: {message}, mutatableInt: {mutatableInt}&quot;);&#10;    mutatableInt = context;&#10;}));&#10;    &#10;int mutatableInt = 1;&#10;customClosure.Delegate.Invoke(customClosure.Context, &quot;Hello World!&quot;, ref mutatableInt); &#10;    // Output: Context: 100, message: Hello World!, mutatableInt: 1&#10;    &#10;Console.WriteLine(mutatableInt); // Output: 100&#10;```&#10;&#10;## Converting to delegates&#10;&#10;Closures can be easily converted to standard .NET delegates (such as `Action` or `Func`) using the provided extension methods.&#10;&#10;You can convert a closure to a delegate using the `AsAction()` or `AsFunc()` extension methods:&#10;&#10;```csharp&#10;var closure = Closure.Action(42, (int ctx) =&gt; Console.WriteLine(ctx));&#10;Action action = closure.AsAction();&#10;action.Invoke(); // Output: 42&#10;&#10;var closureFunc = Closure.Func(&quot;abc&quot;, (string ctx) =&gt; ctx.Length);&#10;Func&lt;int&gt; func = closureFunc.AsFunc();&#10;Console.WriteLine(func.Invoke()); // Output: 3&#10;&#10;// You can also convert closures with arguments:&#10;var closureWithArg = Closure.Action(10, (int ctx, int arg) =&gt; Console.WriteLine($&quot;Context: {ctx}, Arg: {arg}&quot;));&#10;Action&lt;int&gt; actionWithArg = closureWithArg.AsAction&lt;int&gt;();&#10;actionWithArg.Invoke(5); // Output: Context: 10, Arg: 5&#10;```&#10;&#10;However, there is a performance overhead when converting closures to delegates, as it involves boxing the closure and creating a delegate instance.&#10;This is only done once for each closure and then the &quot;invoker&quot; delegate is cached for subsequent invocations.&#10;This means that doing this only once is not better than creating a normal action that captures the context.&#10;&#10;Where it is useful is for example when you want to pass a callback to a method that expects a delegate and need to capture some context without creating a heap allocation.&#10;In this case, you can create a closure and convert it to a delegate, which will be cached for subsequent conversions.&#10;Making it allocation free after the first time it is converted.&#10;&#10;| Method                 |     Mean |     Error |    StdDev | Allocated |&#10;|------------------------|---------:|----------:|----------:|----------:|&#10;| Action                 | 4.850 ns | 0.0602 ns | 0.0563 ns |      88 B |&#10;| ClosureAction_AsAction | 8.985 ns | 0.0445 ns | 0.0395 ns |         - |&#10;&#10;## Closure Types&#10;Closures are categorized into several types based on their functionality and usage patterns. Below is a summary of the different closure types available in the Closures library:&#10;&#10;### Action Closures&#10;- `ClosureAction&lt;TContext&gt;`: Captures a context of type `TContext` and invokes an action with that context.&#10;   &lt;br&gt;&lt;br&gt;&#10;- `ClosureAction&lt;TContext, TArg&gt;`: Captures a context of type `TContext` and invokes an action with an argument of type `TArg`.&#10;   &lt;br&gt;&lt;br&gt;&#10;- `ClosureRefAction&lt;TContext, TArg&gt;`: Captures a context of type `TContext` and invokes an action with a ref argument of type `TArg`.&#10;   &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureAction&lt;TContext&gt;`: Captures a context of type `TContext` by value and invokes a ref action that can mutate the stored context.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureAction&lt;TContext, TArg&gt;`: Captures a context of type `TContext` by value and invokes an action with an argument, allowing mutation of the stored context.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureRefAction&lt;TContext, TArg&gt;`: Captures a context of type `TContext` by value and invokes a ref action with a ref argument, allowing mutation of both context and argument.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureAction&lt;TContext&gt;`: Captures a reference to a context variable of type `TContext` and invokes a ref action, mutating the original variable.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureAction&lt;TContext, TArg&gt;`: Captures a reference to a context variable and invokes an action with an argument, mutating the original variable.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureRefAction&lt;TContext, TArg&gt;`: Captures a reference to a context variable and invokes a ref action with a ref argument, mutating both.&#10;&#10;### Function Closures&#10;- `ClosureFunc&lt;TContext, TResult&gt;`: Captures a context of type `TContext` and invokes a function returning `TResult`.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `ClosureFunc&lt;TContext, TArg, TResult&gt;`: Captures a context of type `TContext` and invokes a function with an argument, returning `TResult`.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `ClosureRefFunc&lt;TContext, TArg, TResult&gt;`: Captures a context of type `TContext` and invokes a function with a ref argument, returning `TResult`.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureFunc&lt;TContext, TResult&gt;`: Captures a context of type `TContext` by value and invokes a ref function, allowing mutation of the stored context.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureFunc&lt;TContext, TArg, TResult&gt;`: Captures a context of type `TContext` by value and invokes a function with an argument, allowing mutation of the stored context.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureRefFunc&lt;TContext, TArg, TResult&gt;`: Captures a context of type `TContext` by value and invokes a ref function with a ref argument, allowing mutation of both context and argument.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureFunc&lt;TContext, TResult&gt;`: Captures a reference to a context variable and invokes a ref function, mutating the original variable.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureFunc&lt;TContext, TArg, TResult&gt;`: Captures a reference to a context variable and invokes a function with an argument, mutating the original variable.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureRefFunc&lt;TContext, TArg, TResult&gt;`: Captures a reference to a context variable and invokes a ref function with a ref argument, mutating both.&#10;&#10;### Anonymous Closures&#10;- `AnonymousClosure`: Represents an anonymous closure that can be used with any delegate type.&#10;&lt;br&gt;&lt;br&gt;&#10;- `AnonymousCLosureAction`: Represents an anonymous closure that can be used with a delegate without a return type.&#10;&lt;br&gt;&lt;br&gt;&#10;- `AnonymousCLosureAction&lt;TArg&gt;`: Represents an anonymous closure that can be used with a delegate that has an argument without a return type.&#10;&lt;br&gt;&lt;br&gt;&#10;- `AnonymousClosureFunc&lt;TReturn&gt;`: Represents an anonymous closure that can be used with a delegate with a return type.&#10;&lt;br&gt;&lt;br&gt;&#10;- `AnonymousCLosureFunc&lt;TArg, TReturn&gt;`: Represents an anonymous closure that can be used with a delegate that has an argument with a return type.&#10;&#10;&#10;### Custom Closure&#10;- `CustomClosure&lt;TContext, TDelegate&gt;`: Represents a custom closure that can be used with any delegate type, allowing you to define your own delegate and use it with the closure.&#10;&#10;## Why?&#10;Due to the nature of closures,&#10;the context is captured as reference.&#10;&#10;The following code might not work as expected:&#10;```csharp&#10;List&lt;Action&gt; actions = new List&lt;Action&gt;();&#10;&#10;for (int i = 0; i &lt; 3; i++) {&#10;    var action = new Action(() =&gt; Console.WriteLine($&quot;{i}&quot;));&#10;    actions.Add(action);&#10;}&#10;&#10;foreach (var action in actions) {&#10;    action.Invoke(); // Output: 3, 3, 3&#10;}&#10;```&#10;You would see the output as `3, 3, 3`&#10;because the variable `i` is captured by reference,&#10;and by the time the actions are invoked,&#10;`i` has already reached its final value of `3`.&#10;&#10;To fix this, you can capture the current value of `i` in a separate variable in each iteration:&#10;```csharp&#10;List&lt;Action&gt; actions = new List&lt;Action&gt;();&#10;&#10;for (int i = 0; i &lt; 3; i++) {&#10;    var tempI = i; // Capture the current value of i&#10;    var action = new Action(() =&gt; Console.WriteLine($&quot;{tempI}&quot;));&#10;    actions.Add(action);&#10;}&#10;&#10;foreach (var action in actions) {&#10;    action.Invoke(); // Output: 0, 1, 2&#10;}&#10;```&#10;You would see the output as `0, 1, 2` Though this works, it allows `tempI` to be captured by the lambda escaping its scope,&#10;creating a closure allocation capture that is allocated on the heap.&#10;&#10;To avoid this overhead, you can use `Closure` structs:&#10;```csharp&#10;using Closures;&#10;&#10;List&lt;ClosureAction&lt;int&gt;&gt; actions = new List&lt;ClosureAction&lt;int&gt;&gt;();&#10;&#10;for (int i = 0; i &lt; 3; i++) {&#10;    // Create a closure that captures the current value of i&#10;    var action = Closure.Action(i, (context) =&gt; Console.WriteLine($&quot;{context}&quot;));&#10;    actions.Add(closure);&#10;}&#10;&#10;foreach (var action in actions) {&#10;    action.Invoke(); // Output: 0, 1, 2&#10;}&#10;```&#10;This way, you avoid unnecessary heap allocations when capturing variables,&#10;which in turn reduces garbage collection overhead.&#10;This is especially beneficial in performance-critical scenarios, such as game development,&#10;where minimizing allocations and maximizing efficiency is crucial.&#10;&#10;Closures Explained: [Closures | In 210 Seconds](https://youtu.be/jHd0FczIjAE?si=5slaULcQxYZN3EES)&lt;br&gt;&#10;Video demonstration of a similar concept: [Fix Closure Issues in 10 Minutes and Boost Performance](https://youtu.be/xiz24OqwEVI?si=gUapklV8JF0FaLTm)&#10;&#10;## License&#10;This project is licensed under the MIT License." />
              <option name="updatedContent" value="# Closures&#10;Closure structs that capture a context and a delegate that is invoked with the given context.&#10;&#10;```csharp&#10;using Closures;&#10;&#10;// Captures 100 as context and prints it when invoked&#10;var closure = Closure.Action(100, &#10;    (context) =&gt; Console.WriteLine($&quot;Captured context {context})&quot;);&#10;    &#10;closure.Invoke(); // Output: Captured context 100&#10;```&#10;## Installation&#10;You can install the Closures library via NuGet Package Manager:&#10;&#10;```bash&#10;Install-Package Closures&#10;```&#10;Or by using the .NET CLI:&#10;&#10;```bash&#10;dotnet add package Closures&#10;```&#10;&#10;Performance benchmarks of the code from the Why? section using closure structs vs capturing variables&#10;in a lambda expression shows significant improvements in execution time and memory allocation.&#10;&#10;### Benchmark Results&#10;&#10;| Method        |      Mean |     Error |    StdDev | Allocated |&#10;|---------------|----------:|----------:|----------:|----------:|&#10;| Action        | 6.7512 ns | 0.0819 ns | 0.0726 ns |      88 B |&#10;| ClosureAction | 0.0103 ns | 0.0046 ns | 0.0043 ns |         - |&#10;&#10;With the benchmark results we can see that using closures is significantly faster than using regular actions or functions that capture variables in a lambda expression.&#10;&#10;The closure struct has a negligible allocation overhead compared to the action that captures variables in a lambda expression.&#10;This is due to the lambda expressions having to box the captured variables and allocate them on the heap,&#10;while the closure struct captures the context by value and does not require heap allocation.&#10;&#10;On top of this since the lambda is capturing the variable it has to allocate a new delegate instance every time it is created&#10;while the closure struct allows for a stateless delegates making it a static method behind the scenes.&#10;&#10;### Table of Contents&#10;- [Basic Closures](#basic-closures)&#10;- [Mutating Closures](#mutating-closures)&#10;- [Ref Closures](#ref-closures)&#10;- [Anonymous Closures](#anonymous-closures)&#10;- [Custom Closure](#custom-closure)&#10;- [Converting to Delegates](#converting-to-delegates)&#10;- [Closure Types](#closure-types)&#10;&#10;## Usage&#10;To use the closures, simply create an instance of the desired closure type using the `Closure.Action` or `Closure.Func` methods, &#10;passing in the context and the delegate to be invoked. The closures can then be invoked like a delegate.&#10;&#10;### Basic closures&#10;- `ClosureAction&lt;TContext&gt;` that captures a string context.&#10;- `ClosureFunc&lt;TContext, TReturn&gt;` that captures an int context and returns a doubled value.&#10;&#10;```csharp&#10;// Example of ClosureAction&#10;var closureAction = Closure.Action(&quot;captured context&quot;, &#10;    (string context) =&gt; Console.WriteLine($&quot;Action with context - {context}&quot;));&#10;&#10;closureAction.Invoke(); // Output: Action with context - captured context&#10;&#10;// Example of ClosureFunc&#10;var closureFunc = Closure.Func(10, (int context) =&gt; context * 2);&#10;Console.WriteLine(closureFunc.Invoke()); // Output: 20&#10;```&#10;&#10;### Passing an argument&#10;Closures can also take in an argument when invoking them.&#10;The context is always passed as the first parameter, followed by the argument.&#10;- `ClosureAction&lt;TContext, TArg&gt;` that captures an int context and is called with an int argument.&#10;- `ClosureFunc&lt;TContext, TArg, TResult&gt;` that captures an int context, is called with an int argument and returns the sum of the context and argument.&#10;&#10;```csharp &#10;// Example of ClosureAction with an argument&#10;var closureActionWithArg = Closure.Action(10, (int context, int arg) =&gt; &#10;    Console.WriteLine($&quot;Context: {context}, Arg: {arg}&quot;));&#10;&#10;closureActionWithArg.Invoke(5); // Output: Context: 10, Arg: 5&#10;    &#10;// Example of ClosureFunc with an argument&#10;var closureFuncWithArg = Closure.Func(10, (int context, int arg) =&gt; context + arg);&#10;Console.WriteLine(closureFuncWithArg.Invoke(5)); // Output: 15&#10;```&#10;&#10;Arguments can also be passed as `ref`, allowing the closure to modify the argument value.&#10;- `ClosureRefAction&lt;TContext, TArg&gt;` that captures an int context and is called with a ref int argument which is set to the value of context.&#10;- `ClosureRefFunc&lt;TContext, TArg, TResult&gt;` that captures an int context, is called with a ref int argument which is set to the value of context and returns the sum of the context and argument.&#10;&#10;```csharp&#10;// Example of ClosureAction with a ref argument&#10;int arg = 5;&#10;var closureActionWithRefArg = Closure.RefAction(10, (int context, ref int arg) =&gt; arg = context);&#10;closureActionWithRefArg.Invoke(ref arg);&#10;Console.WriteLine(arg); // Output: 10&#10;    &#10;// Example of ClosureFunc with a ref argument&#10;var funcArg = 5;&#10;var closureFuncWithRefArg = Closure.RefFunc(10, (int context, ref int arg) =&gt; {&#10;    var sum = context + arg;&#10;    arg = context;&#10;    return sum;&#10;});&#10;var returnValue = closureFuncWithRefArg.Invoke(ref funcArg);&#10;Console.WriteLine(returnValue); // Output: 15&#10;Console.WriteLine(funcArg); // Output: 10&#10;```&#10;&#10;### Mutating closures&#10;Mutating closures allow you to modify the captured context within the delegate. &#10;They are useful when you want to invoke the closure multiple times with the context being modified each time.&#10;&#10;- `MutatingClosureAction&lt;TContext&gt;` that captures a mutable context.&#10;- `MutatingClosureFunc&lt;TContext, TReturn&gt;` that captures a mutable context and returns the sum of modifications.&#10;&#10;```csharp&#10;// Example of MutatingClosureAction&#10;var mutatingClosureAction = MutatingClosure.Action(10, (ref int context) =&gt; {&#10;    Console.WriteLine(context)&#10;    context += 5&#10;});&#10;mutatingClosureAction.Invoke(); // Output: 10&#10;mutatingClosureAction.Invoke(); // Output: 15&#10;&#10;// Example of MutatingClosureFunc&#10;var mutatingClosureFunc = Closure.Func(20, (ref int context) =&gt; context *= 2);&#10;Console.WriteLine(mutatingClosureFunc.Invoke()); // Output: 40&#10;Console.WriteLine(mutatingClosureFunc.Invoke()); // Output: 80&#10;```&#10;&#10;### Ref closures&#10;Ref closures work similarly to mutating closures with the difference being that &#10;they are ref structs that capture a reference to a context variable, allowing it to modify the original variable.&#10;&#10;- `RefActionClosure&lt;TContext&gt;` that captures a reference to a mutable context.&#10;- `RefFuncClosure&lt;TContext, TReturn&gt;` that captures a reference to a mutable context and returns a modified value.&#10;&#10;```csharp&#10;// Example of RefActionClosure&#10;var refContext = 10;&#10;var refClosureAction = RefClosure.Action(ref refContext, (ref int context) =&gt; {&#10;    Console.WriteLine(context);&#10;    context += 10;&#10;});&#10;&#10;refClosureAction.Invoke(); // Output: 10&#10;Console.WriteLine(refContext); // Output: 20&#10;&#10;refClosureAction.Invoke(); // Output: 20&#10;Console.WriteLine(refContext); // Output: 30&#10;&#10;// Example of RefFuncClosure&#10;var refFuncContext = 10;&#10;var refClosureFunc = RefClosure.Func(ref refFuncContext, (ref int context) =&gt; {&#10;    context *= 2;&#10;    return context * 2;&#10;});&#10;&#10;Console.WriteLine(refClosureFunc.Invoke()); // Output: 40&#10;Console.WriteLine(refFuncContext); // Output: 20&#10;&#10;Console.WriteLine(refClosureFunc.Invoke()); // Output: 80&#10;Console.WriteLine(refFuncContext); // Output: 40&#10;```&#10;&#10;### Anonymous closures&#10;&#10;Anonymous closures provide a type-erased, flexible way to store and invoke closures (delegates with captured context) without knowing the exact context or delegate type at compile time. They are useful when you need to work with closures in a generic or dynamic fashion, such as storing heterogeneous closures in collections, passing them through APIs, or bridging between different closure types.&#10;&#10;Anonymous closures encapsulate:&#10;- A delegate (action or function, with or without arguments)&#10;- An `AnonymousValue` context (a type-erased container for any value or reference type)&#10;- A `MutatingBehaviour` (controls whether the context is mutated or reset after invocation)&#10;&#10;#### Types&#10;&#10;- `AnonymousClosure`: The core type-erased closure struct. It can represent any closure (action or function, with or without arguments or return value). It exposes generic `Invoke` and `TryInvoke` methods for all supported delegate signatures.&#10;- `AnonymousClosureAction`: Represents an anonymous closure for a delegate with no arguments and no return value (action).&#10;- `AnonymousClosureAction&lt;TArg&gt;`: Represents an anonymous closure for a delegate with a single argument and no return value.&#10;- `AnonymousClosureFunc&lt;TReturn&gt;`: Represents an anonymous closure for a delegate with no arguments and a return value.&#10;- `AnonymousClosureFunc&lt;TArg, TReturn&gt;`: Represents an anonymous closure for a delegate with a single argument and a return value.&#10;&#10;All anonymous closure types implement the `IAnonymousClosure` interface, which provides access to the context, delegate, and mutating behaviour, as well as:&#10;- `Is&lt;TClosureType&gt;()`: Checks if the anonymous closure can be converted to a specific strongly-typed closure type.&#10;- `InvokableAs&lt;TDelegate&gt;()`: Checks if the anonymous closure can be invoked as if it was a delegate of type `TDelegate`.&#10;&#10;#### Mutating Behaviour&#10;&#10;The `MutatingBehaviour` enum controls whether the context is mutated (`Mutate`) or reset (`Reset`) after invocation. This allows you to choose between closures that modify their captured context (like mutating closures) and those that do not.&#10;&#10;#### Usage&#10;&#10;You can create anonymous closures using the static factory methods on `AnonymousClosure`, such as:&#10;&#10;```csharp&#10;// Create an anonymous action closure&#10;var anonAction = AnonymousClosure.Action(AnonymousValue.From(42), (int ctx) =&gt; Console.WriteLine(ctx));&#10;&#10;// Create an anonymous function closure with a return value&#10;var anonFunc = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(&quot;hello&quot;), (string ctx) =&gt; ctx.Length);&#10;&#10;// Create an anonymous closure from a strongly-typed closure&#10;var closure = Closure.Action(100, (int ctx) =&gt; Console.WriteLine(ctx));&#10;AnonymousClosure anon = closure.AsAnonymous();&#10;```&#10;&#10;You can invoke anonymous closures using their `Invoke` or `TryInvoke` methods. The `TryInvoke` methods return a `Result` or `Result&lt;T&gt;` indicating success or failure, and allow you to specify an `ExceptionHandlingPolicy` to control how exceptions are handled.&#10;&#10;```csharp&#10;anonAction.Invoke(); // Invokes the action&#10;var result = anonFunc.TryInvoke(); // Returns Result&lt;int&gt;&#10;if (result.IsSuccess) {&#10;    Console.WriteLine(result.Value);&#10;}&#10;```&#10;&#10;#### Type Checking and Invocation&#10;&#10;You can use `Is&lt;TClosureType&gt;()` to check if an anonymous closure can be converted to a specific strongly-typed closure type, and then convert it back using the appropriate extension method:&#10;&#10;You can use `InvokableAs&lt;TDelegate&gt;()` to check if an anonymous closure can be invoked as if it was a specific delegate type.&#10;&#10;Anonymous closures can be converted back to strongly-typed closures (if the types match) using extension methods such as `AsClosureAction&lt;TContext&gt;()` or `AsClosureFunc&lt;TContext, TResult&gt;()`.&#10;&#10;Example:&#10;&#10;```csharp&#10;// Store different closures in a single list&#10;var list = new List&lt;AnonymousClosure&gt;();&#10;list.Add(Closure.Action(1, (int ctx) =&gt; Console.WriteLine(ctx)).AsAnonymous());&#10;list.Add(Closure.Func(&quot;abc&quot;, (string ctx) =&gt; ctx.Length).AsAnonymous());&#10;&#10;foreach (var anon in list) {&#10;    if (anon.InvokableAs&lt;Func&lt;int&gt;&gt;())&#10;        Console.WriteLine(anon.Invoke&lt;int&gt;());&#10;    else if (anon.InvokableAs&lt;Action&gt;())&#10;        anon.Invoke();&#10;}&#10;&#10;// Example: Checking type and converting back to a strongly-typed closure&#10;var anonClosure = Closure.Func(&quot;hello&quot;, (string ctx) =&gt; ctx.Length).AsAnonymous();&#10;if (anonClosure.Is&lt;ClosureFunc&lt;string, int&gt;&gt;()) {&#10;    var typed = anonClosure.AsClosureFunc&lt;string, int&gt;();&#10;    Console.WriteLine(typed.Invoke()); // Output: 5&#10;}&#10;```&#10;&#10;#### Remarks&#10;&#10;- Anonymous closures are type-erased and do not enforce type safety at compile time. You must ensure that the delegate and context types are compatible when converting or invoking.&#10;- Useful for storing closures of different types in a single collection, or for APIs that need to accept arbitrary closures.&#10;&#10;However, with the flexibility comes some performance overhead compared to strongly-typed closures, so use them judiciously in performance-critical scenarios.&#10;&#10;| Method                    |       Mean |     Error |    StdDev | Allocated |&#10;|---------------------------|-----------:|----------:|----------:|----------:|&#10;| Action                    |  4.7119 ns | 0.0502 ns | 0.0445 ns |      88 B |&#10;| ClosureAction             |  0.0221 ns | 0.0044 ns | 0.0039 ns |         - |&#10;| ClosureAction_AsAnonymous | 25.8292 ns | 0.0883 ns | 0.0783 ns |         - |&#10;&#10;### Custom Closure&#10;You can use `Closure.Custom&lt;TContext, TDelegate&gt;(TContext, TDelegate)` to create a closure with a custom delegate type.&#10;This allows you to define your own delegate type and use it with the closure.&#10;However, you must call the delegate manually using the `Delegate` property and pass the context and arguments as needed.&#10;Essentially this just wraps the delegate and context in a struct, allowing you to use any delegate type with the closure.&#10;```csharp&#10;delegate void CustomDelegate(int context, string message, ref int mutatableInt);&#10;&#10;var customClosure = Closure.Custom&lt;int, CustomDelegate&gt;(100, &#10;    (int context, string message, ref int mutatableInt) =&gt; {&#10;    Console.WriteLine($&quot;Context: {context}, message: {message}, mutatableInt: {mutatableInt}&quot;);&#10;    mutatableInt = context;&#10;}));&#10;    &#10;int mutatableInt = 1;&#10;customClosure.Delegate.Invoke(customClosure.Context, &quot;Hello World!&quot;, ref mutatableInt); &#10;    // Output: Context: 100, message: Hello World!, mutatableInt: 1&#10;    &#10;Console.WriteLine(mutatableInt); // Output: 100&#10;```&#10;&#10;## Converting to delegates&#10;&#10;Closures can be easily converted to standard .NET delegates (such as `Action` or `Func`) using the provided extension methods.&#10;&#10;You can convert a closure to a delegate using the `AsAction()` or `AsFunc()` extension methods:&#10;&#10;```csharp&#10;var closure = Closure.Action(42, (int ctx) =&gt; Console.WriteLine(ctx));&#10;Action action = closure.AsAction();&#10;action.Invoke(); // Output: 42&#10;&#10;var closureFunc = Closure.Func(&quot;abc&quot;, (string ctx) =&gt; ctx.Length);&#10;Func&lt;int&gt; func = closureFunc.AsFunc();&#10;Console.WriteLine(func.Invoke()); // Output: 3&#10;&#10;// You can also convert closures with arguments:&#10;var closureWithArg = Closure.Action(10, (int ctx, int arg) =&gt; Console.WriteLine($&quot;Context: {ctx}, Arg: {arg}&quot;));&#10;Action&lt;int&gt; actionWithArg = closureWithArg.AsAction&lt;int&gt;();&#10;actionWithArg.Invoke(5); // Output: Context: 10, Arg: 5&#10;```&#10;&#10;However, there is a performance overhead when converting closures to delegates, as it involves boxing the closure and creating a delegate instance.&#10;This is only done once for each closure and then the &quot;invoker&quot; delegate is cached for subsequent invocations.&#10;This means that doing this only once is not better than creating a normal action that captures the context.&#10;&#10;Where it is useful is for example when you want to pass a callback to a method that expects a delegate and need to capture some context without creating a heap allocation.&#10;In this case, you can create a closure and convert it to a delegate, which will be cached for subsequent conversions.&#10;Making it allocation free after the first time it is converted.&#10;&#10;| Method                 |     Mean |     Error |    StdDev | Allocated |&#10;|------------------------|---------:|----------:|----------:|----------:|&#10;| Action                 | 4.850 ns | 0.0602 ns | 0.0563 ns |      88 B |&#10;| ClosureAction_AsAction | 8.985 ns | 0.0445 ns | 0.0395 ns |         - |&#10;&#10;### Cache Management with ClosureManager&#10;&#10;The `ClosureManager` class provides a static method `ClearCache()` that clears all internal caches used by the Closures system. This can be useful for freeing up memory if you know that most cached values will no longer be needed. For example, in a video game, you might want to call `ClosureManager.ClearCache()` during a major loading screen or scene transition, when much of the code and its associated closures are about to change.&#10;&#10;```csharp&#10;// Clear all closure-related caches to free up memory&#10;ClosureManager.ClearCache();&#10;```&#10;&#10;This operation is safe and can help reduce memory usage in scenarios where many closures and delegate conversions have been cached but are no longer relevant.&#10;&#10;## Closure Types&#10;Closures are categorized into several types based on their functionality and usage patterns. Below is a summary of the different closure types available in the Closures library:&#10;&#10;### Action Closures&#10;- `ClosureAction&lt;TContext&gt;`: Captures a context of type `TContext` and invokes an action with that context.&#10;   &lt;br&gt;&lt;br&gt;&#10;- `ClosureAction&lt;TContext, TArg&gt;`: Captures a context of type `TContext` and invokes an action with an argument of type `TArg`.&#10;   &lt;br&gt;&lt;br&gt;&#10;- `ClosureRefAction&lt;TContext, TArg&gt;`: Captures a context of type `TContext` and invokes an action with a ref argument of type `TArg`.&#10;   &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureAction&lt;TContext&gt;`: Captures a context of type `TContext` by value and invokes a ref action that can mutate the stored context.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureAction&lt;TContext, TArg&gt;`: Captures a context of type `TContext` by value and invokes an action with an argument, allowing mutation of the stored context.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureRefAction&lt;TContext, TArg&gt;`: Captures a context of type `TContext` by value and invokes a ref action with a ref argument, allowing mutation of both context and argument.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureAction&lt;TContext&gt;`: Captures a reference to a context variable of type `TContext` and invokes a ref action, mutating the original variable.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureAction&lt;TContext, TArg&gt;`: Captures a reference to a context variable and invokes an action with an argument, mutating the original variable.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureRefAction&lt;TContext, TArg&gt;`: Captures a reference to a context variable and invokes a ref action with a ref argument, mutating both.&#10;&#10;### Function Closures&#10;- `ClosureFunc&lt;TContext, TResult&gt;`: Captures a context of type `TContext` and invokes a function returning `TResult`.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `ClosureFunc&lt;TContext, TArg, TResult&gt;`: Captures a context of type `TContext` and invokes a function with an argument, returning `TResult`.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `ClosureRefFunc&lt;TContext, TArg, TResult&gt;`: Captures a context of type `TContext` and invokes a function with a ref argument, returning `TResult`.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureFunc&lt;TContext, TResult&gt;`: Captures a context of type `TContext` by value and invokes a ref function, allowing mutation of the stored context.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureFunc&lt;TContext, TArg, TResult&gt;`: Captures a context of type `TContext` by value and invokes a function with an argument, allowing mutation of the stored context.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `MutatingClosureRefFunc&lt;TContext, TArg, TResult&gt;`: Captures a context of type `TContext` by value and invokes a ref function with a ref argument, allowing mutation of both context and argument.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureFunc&lt;TContext, TResult&gt;`: Captures a reference to a context variable and invokes a ref function, mutating the original variable.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureFunc&lt;TContext, TArg, TResult&gt;`: Captures a reference to a context variable and invokes a function with an argument, mutating the original variable.&#10;  &lt;br&gt;&lt;br&gt;&#10;- `RefClosureRefFunc&lt;TContext, TArg, TResult&gt;`: Captures a reference to a context variable and invokes a ref function with a ref argument, mutating both.&#10;&#10;### Anonymous Closures&#10;- `AnonymousClosure`: Represents an anonymous closure that can be used with any delegate type.&#10;&lt;br&gt;&lt;br&gt;&#10;- `AnonymousCLosureAction`: Represents an anonymous closure that can be used with a delegate without a return type.&#10;&lt;br&gt;&lt;br&gt;&#10;- `AnonymousCLosureAction&lt;TArg&gt;`: Represents an anonymous closure that can be used with a delegate that has an argument without a return type.&#10;&lt;br&gt;&lt;br&gt;&#10;- `AnonymousClosureFunc&lt;TReturn&gt;`: Represents an anonymous closure that can be used with a delegate with a return type.&#10;&lt;br&gt;&lt;br&gt;&#10;- `AnonymousCLosureFunc&lt;TArg, TReturn&gt;`: Represents an anonymous closure that can be used with a delegate that has an argument with a return type.&#10;&#10;&#10;### Custom Closure&#10;- `CustomClosure&lt;TContext, TDelegate&gt;`: Represents a custom closure that can be used with any delegate type, allowing you to define your own delegate and use it with the closure.&#10;&#10;## Why?&#10;Due to the nature of closures,&#10;the context is captured as reference.&#10;&#10;The following code might not work as expected:&#10;```csharp&#10;List&lt;Action&gt; actions = new List&lt;Action&gt;();&#10;&#10;for (int i = 0; i &lt; 3; i++) {&#10;    var action = new Action(() =&gt; Console.WriteLine($&quot;{i}&quot;));&#10;    actions.Add(action);&#10;}&#10;&#10;foreach (var action in actions) {&#10;    action.Invoke(); // Output: 3, 3, 3&#10;}&#10;```&#10;You would see the output as `3, 3, 3`&#10;because the variable `i` is captured by reference,&#10;and by the time the actions are invoked,&#10;`i` has already reached its final value of `3`.&#10;&#10;To fix this, you can capture the current value of `i` in a separate variable in each iteration:&#10;```csharp&#10;List&lt;Action&gt; actions = new List&lt;Action&gt;();&#10;&#10;for (int i = 0; i &lt; 3; i++) {&#10;    var tempI = i; // Capture the current value of i&#10;    var action = new Action(() =&gt; Console.WriteLine($&quot;{tempI}&quot;));&#10;    actions.Add(action);&#10;}&#10;&#10;foreach (var action in actions) {&#10;    action.Invoke(); // Output: 0, 1, 2&#10;}&#10;```&#10;You would see the output as `0, 1, 2` Though this works, it allows `tempI` to be captured by the lambda escaping its scope,&#10;creating a closure allocation capture that is allocated on the heap.&#10;&#10;To avoid this overhead, you can use `Closure` structs:&#10;```csharp&#10;using Closures;&#10;&#10;List&lt;ClosureAction&lt;int&gt;&gt; actions = new List&lt;ClosureAction&lt;int&gt;&gt;();&#10;&#10;for (int i = 0; i &lt; 3; i++) {&#10;    // Create a closure that captures the current value of i&#10;    var action = Closure.Action(i, (context) =&gt; Console.WriteLine($&quot;{context}&quot;));&#10;    actions.Add(closure);&#10;}&#10;&#10;foreach (var action in actions) {&#10;    action.Invoke(); // Output: 0, 1, 2&#10;}&#10;```&#10;This way, you avoid unnecessary heap allocations when capturing variables,&#10;which in turn reduces garbage collection overhead.&#10;This is especially beneficial in performance-critical scenarios, such as game development,&#10;where minimizing allocations and maximizing efficiency is crucial.&#10;&#10;Closures Explained: [Closures | In 210 Seconds](https://youtu.be/jHd0FczIjAE?si=5slaULcQxYZN3EES)&lt;br&gt;&#10;Video demonstration of a similar concept: [Fix Closure Issues in 10 Minutes and Boost Performance](https://youtu.be/xiz24OqwEVI?si=gUapklV8JF0FaLTm)&#10;&#10;## License&#10;This project is licensed under the MIT License." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>