<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ClosureTests/ActionTests/AnonymousClosure/AnonymousClosureTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/ActionTests/AnonymousClosure/AnonymousClosureTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.ActionTests.AnonymousClosure;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    // Normal Actions&#10;    [Test]&#10;    public void ClosureActionAsAnonymousAndBack() {&#10;        int expected = 10;&#10;        int received = 0;&#10;        &#10;        var closureAction = Closure.Action(expected, context =&gt; received = context);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int&gt;().Invoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context value.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void ClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    [Test]&#10;    public void ClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, ref int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureRefAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    // Mutating Actions&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.ActionTests.AnonymousClosure;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    // Normal Actions&#10;    [Test]&#10;    public void ClosureActionAsAnonymousAndBack() {&#10;        int expected = 10;&#10;        int received = 0;&#10;        &#10;        var closureAction = Closure.Action(expected, context =&gt; received = context);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int&gt;().Invoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context value.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void ClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    [Test]&#10;    public void ClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, ref int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureRefAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    // Mutating Actions&#10;    [Test]&#10;    public void MutatingClosureActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int expected = context + 5;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c) =&gt; c += 5, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureAction&lt;int&gt;().Invoke();&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureAction did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void MutatingClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 7;&#10;        int expected = context + arg;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c, int a) =&gt; c += a, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureActionWithArg did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void MutatingClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c, ref int a) =&gt; c += a, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureRefAction&lt;int, int&gt;().Invoke(ref arg);&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureRefAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureRefAction did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction))]&#10;public class AnonymousClosureActionTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    &#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        a.Invoke();&#10;        &#10;        var b = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction))]&#10;public class AnonymousClosureActionTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    &#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx) =&gt; ctx += addition,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke();&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;&#10;        var anon = AnonymousClosure.Action(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx) =&gt; ctx.testContext.Value = ctx.value = expected,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;        Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        a.Invoke();&#10;        &#10;        var b = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionWithArgTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionWithArgTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction&lt;&gt;))]&#10;public class AnonymousClosureActionWithArgTest {&#10;&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesContext() {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; ctx += addition,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; ctx.testContext.Value = ctx.value = expected,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Anonymous tests&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx * arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(15));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx * arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(20));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        int arg = 1;&#10;        a.Invoke(arg);&#10;&#10;        var b = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction&lt;&gt;))]&#10;public class AnonymousClosureActionWithArgTest {&#10;&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesContext() {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; { Assert.That(ctx, Is.EqualTo(expected)); });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; { ctx.testContext.Value = ctx.expected; });&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; { Assert.That(ctx + a, Is.EqualTo(expected)); });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; { Assert.That(ctx + a, Is.EqualTo(expected)); });&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; { val += ctx; });&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; { val += ctx; });&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; { ctx += addition; },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; { ctx.testContext.Value = ctx.value = expected; },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Anonymous tests&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { calledWith = ctx * arg; };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(15));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { calledWith = ctx * arg; };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(20));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { throw new InvalidCastException(&quot;fail&quot;); };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { throw new InvalidCastException(&quot;fail&quot;); };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        int arg = 1;&#10;        a.Invoke(arg);&#10;&#10;        var b = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureCreationTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureCreationTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureCreationTests&#10;{&#10;    [Test]&#10;    public void AnonymousClosure_Action_CreatesCorrectly()&#10;    {&#10;        int context = 42;&#10;        Action&lt;int&gt; action = _ =&gt; { };&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_WithArg_CreatesCorrectly()&#10;    {&#10;        int context = 7;&#10;        Action&lt;int, string&gt; action = (_, __) =&gt; { };&#10;        var anon = AnonymousClosure.Action&lt;string&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 5;&#10;        RefAction&lt;int&gt; action = (ref int x) =&gt; x++;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_WithArg_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 3;&#10;        ActionWithRefContext&lt;int, string&gt; action = (ref int x, string s) =&gt; x += s.Length;&#10;        var anon = AnonymousClosure.Action&lt;string&gt;(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_CreatesCorrectly()&#10;    {&#10;        int context = 10;&#10;        Func&lt;int, string&gt; func = x =&gt; x.ToString();&#10;        var anon = AnonymousClosure.Func&lt;string&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_WithArg_CreatesCorrectly()&#10;    {&#10;        int context = 8;&#10;        Func&lt;int, string, string&gt; func = (x, s) =&gt; (x + s.Length).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string, string&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 2;&#10;        RefFunc&lt;int, string&gt; func = (ref int x) =&gt; (++x).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_WithArg_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 4;&#10;        FuncWithRefContext&lt;int, string, string&gt; func = (ref int x, string s) =&gt; (x += s.Length).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string, string&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureCreationTests&#10;{&#10;    [Test]&#10;    public void AnonymousClosure_Action_CreatesCorrectly()&#10;    {&#10;        int context = 42;&#10;        Action&lt;int&gt; action = _ =&gt; { };&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_WithArg_CreatesCorrectly()&#10;    {&#10;        int context = 7;&#10;        Action&lt;int, string&gt; action = (_, __) =&gt; { };&#10;        var anon = AnonymousClosure.Action&lt;string&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 5;&#10;        RefAction&lt;int&gt; action = (ref int x) =&gt; x++;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_WithArg_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 3;&#10;        ActionWithRefContext&lt;int, string&gt; action = (ref int x, string s) =&gt; x += s.Length;&#10;        var anon = AnonymousClosure.Action&lt;string&gt;(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_CreatesCorrectly()&#10;    {&#10;        int context = 10;&#10;        Func&lt;int, string&gt; func = x =&gt; x.ToString();&#10;        var anon = AnonymousClosure.Func&lt;string&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_WithArg_CreatesCorrectly()&#10;    {&#10;        int context = 8;&#10;        Func&lt;int, string, string&gt; func = (x, s) =&gt; (x + s.Length).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string, string&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 2;&#10;        RefFunc&lt;int, string&gt; func = (ref int x) =&gt; (++x).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_WithArg_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 4;&#10;        FuncWithRefContext&lt;int, string, string&gt; func = (ref int x, string s) =&gt; (x += s.Length).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string, string&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Create_CreatesCorrectly()&#10;    {&#10;        int context = 123;&#10;        Action&lt;int&gt; action = _ =&gt; { };&#10;        var anon = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Create_WithMutatingBehaviour_CreatesCorrectly()&#10;    {&#10;        int context = 456;&#10;        RefAction&lt;int&gt; action = (ref int x) =&gt; x++;&#10;        var anon = AnonymousClosure.Create(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Create_GenericDelegate_CreatesCorrectly()&#10;    {&#10;        int context = 789;&#10;        Func&lt;int, string&gt; func = x =&gt; x.ToString();&#10;        var anon = AnonymousClosure.Create&lt;Func&lt;int, string&gt;&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Create_GenericDelegate_WithMutatingBehaviour_CreatesCorrectly()&#10;    {&#10;        int context = 321;&#10;        RefFunc&lt;int, string&gt; func = (ref int x) =&gt; (++x).ToString();&#10;        var anon = AnonymousClosure.Create&lt;RefFunc&lt;int, string&gt;&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureExtensionsTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureExtensionsTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureExtensions))]&#10;public class AnonymousClosureExtensionsTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureExtensions))]&#10;public class AnonymousClosureExtensionsTest {&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;&gt;))]&#10;public class AnonymousClosureFuncTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx;&#10;        });&#10;&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From((testContext, expected)),&#10;            ((TestClass testContext, int expected) ctx) =&gt; {&#10;                ctx.testContext.Value = ctx.expected;&#10;                return ctx.expected;&#10;            });&#10;&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReturnsExpectedValue() {&#10;        int context = 10;&#10;        int expected = context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 2);&#10;&#10;        int result = anon.Invoke();&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx + 1;&#10;&#10;        var a = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;&gt;))]&#10;public class AnonymousClosureFuncTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx;&#10;        });&#10;&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From((testContext, expected)),&#10;            ((TestClass testContext, int expected) ctx) =&gt; {&#10;                ctx.testContext.Value = ctx.expected;&#10;                return ctx.expected;&#10;            });&#10;&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReturnsExpectedValue() {&#10;        int context = 10;&#10;        int expected = context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 2);&#10;&#10;        int result = anon.Invoke();&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvokeBool_ReturnsTrueAndResult_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        bool success = anon.TryInvoke(out int result);&#10;        Assert.That(success, Is.True);&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvokeBool_ReturnsFalseAndDefault_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        bool success = anon.TryInvoke(out int result);&#10;        Assert.That(success, Is.False);&#10;        Assert.That(result, Is.EqualTo(default(int)));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx + 1;&#10;&#10;        var a = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncWithArgTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncWithArgTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;,&gt;))]&#10;public class AnonymousClosureFuncWithArgTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;,&gt;))]&#10;public class AnonymousClosureFuncWithArgTest&#10;{&#10;    class TestClass&#10;    {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesContext()&#10;    {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesTupleContext_AndModifiesTestContextValue()&#10;    {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; {&#10;            ctx.testContext.Value = ctx.expected;&#10;            return ctx.expected + a;&#10;        });&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesArg()&#10;    {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; {&#10;            Assert.That(ctx + a, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesRefArg()&#10;    {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; {&#10;            Assert.That(ctx + a, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ModifiesRefArgValue()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; {&#10;            val += ctx;&#10;            return val;&#10;        });&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ModifiesRefArgValue_MultipleInvocations()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; {&#10;            val += ctx;&#10;            return val;&#10;        });&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_MutatingContext_RetainsModifiedContext()&#10;    {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; {&#10;                ctx += addition;&#10;                return ctx + a;&#10;            },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_MutatingTupleContext_RetainsModifiedContext()&#10;    {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; {&#10;                ctx.testContext.Value = ctx.value = expected;&#10;                return ctx.value + a;&#10;            },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReturnsExpectedValue()&#10;    {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;        int result = anon.Invoke(arg);&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvoke_ReturnsSuccess_OnValidCall()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;&#10;        var result = anon.TryInvoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvoke_ReturnsFailure_OnException()&#10;    {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;));&#10;&#10;        var result = anon.TryInvoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvokeBool_ReturnsTrueAndResult_OnValidCall()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;&#10;        bool success = anon.TryInvoke(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.True);&#10;            Assert.That(result, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvokeBool_ReturnsFalseAndDefault_OnException()&#10;    {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;));&#10;&#10;        bool success = anon.TryInvoke(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.False);&#10;            Assert.That(result, Is.EqualTo(default(int)));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_Equals_And_HashCode_Work()&#10;    {&#10;        int context = 7;&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;&#10;        var a = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke(1);&#10;&#10;        var b = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    // Default tests&#10;        &#10;    [Test]&#10;    public void Action_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        closure.Invoke();&#10;    }&#10;        &#10;    [Test]&#10;    public void Action_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;&#10;        var testContext = new TestClass();&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; { &#10;            ctx.testContext.Value = ctx.expected;&#10;        });&#10;        closure.Invoke();&#10;&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(arg);&#10;    }&#10;    &#10;    // Ref argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(ref arg);&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Mutating tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourMutate_RetainsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context + addition;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Mutate);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourReset_ResetsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Reset);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Func Tests&#10;&#10;    [Test]&#10;    public void Func_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx);&#10;        var result = closure.Invoke&lt;int&gt;();&#10;        &#10;        Assert.That(result, Is.EqualTo(context), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(argument);&#10;        &#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func ref arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithRefArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(ref argument);&#10;&#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Anonymous Action Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Func Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Is_Works() {&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(42), (int ctx) =&gt; { });&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(closure.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True);&#10;            Assert.That(closure.Is&lt;MutatingClosureFunc&lt;int, int&gt;&gt;(), Is.False);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    // Default tests&#10;        &#10;    [Test]&#10;    public void Action_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        closure.Invoke();&#10;    }&#10;        &#10;    [Test]&#10;    public void Action_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;&#10;        var testContext = new TestClass();&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; { &#10;            ctx.testContext.Value = ctx.expected;&#10;        });&#10;        closure.Invoke();&#10;&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(arg);&#10;    }&#10;    &#10;    // Ref argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(ref arg);&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Mutating tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourMutate_RetainsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context + addition;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Mutate);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourReset_ResetsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Reset);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Func Tests&#10;&#10;    [Test]&#10;    public void Func_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx);&#10;        var result = closure.Invoke&lt;int&gt;();&#10;        &#10;        Assert.That(result, Is.EqualTo(context), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(argument);&#10;        &#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func ref arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithRefArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(ref argument);&#10;&#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Anonymous Action Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Func Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Is_Works() {&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(42), (int ctx) =&gt; { });&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(closure.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True);&#10;            Assert.That(closure.Is&lt;MutatingClosureFunc&lt;int, int&gt;&gt;(), Is.False);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;&#10;    // TryInvoke with arg&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(8));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // TryInvoke with ref arg&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithRefArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = closure.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(9));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithRefArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = closure.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke with arg&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx + a);&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke with ref arg&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithRefArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; ctx + a);&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithRefArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke bool out result&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvokeBool_WithArg_ReturnsTrueAndResult_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx + a);&#10;&#10;        bool success = closure.TryInvoke&lt;int, int&gt;(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.True);&#10;            Assert.That(result, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvokeBool_WithArg_ReturnsFalseAndDefault_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        bool success = closure.TryInvoke&lt;int, int&gt;(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.False);&#10;            Assert.That(result, Is.EqualTo(default(int)));&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousHelperTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousHelperTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousHelper))]&#10;public class AnonymousHelperTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;using System;&#10;using System.Linq;&#10;using System.Reflection;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousHelper))]&#10;public class AnonymousHelperTest&#10;{&#10;    private class DummyClosure : IClosure&lt;int, Action&lt;int&gt;&gt;&#10;    {&#10;        public int Context { get; }&#10;        public Action&lt;int&gt; Action { get; }&#10;        public DummyClosure(int ctx, Action&lt;int&gt; action) { Context = ctx; Action = action; }&#10;    }&#10;&#10;    private class DummyAnonymousClosure : IAnonymousClosure&#10;    {&#10;        public AnonymousValue Context { get; set; }&#10;        public Delegate Delegate { get; set; }&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceType_ReturnsCorrectInterface()&#10;    {&#10;        var type = AnonymousHelper.GetInterfaceType&lt;DummyClosure&gt;();&#10;        Assert.That(type, Is.EqualTo(typeof(IClosure&lt;int, Action&lt;int&gt;&gt;)));&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceType_ThrowsIfNoInterface()&#10;    {&#10;        Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; AnonymousHelper.GetInterfaceType&lt;AnonymousHelperTest&gt;());&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceGenericArguments_ReturnsCorrectArguments()&#10;    {&#10;        var iface = typeof(IClosure&lt;int, Action&lt;int&gt;&gt;);&#10;        var args = AnonymousHelper.GetInterfaceGenericArguments(iface);&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(Action&lt;int&gt;) }));&#10;    }&#10;&#10;    [Test]&#10;    public void CanConvert_ReturnsTrueForMatchingTypes()&#10;    {&#10;        var anon = new DummyAnonymousClosure&#10;        {&#10;            Context = AnonymousValue.Int(42),&#10;            Delegate = new Action&lt;int&gt;(_ =&gt; { })&#10;        };&#10;        Assert.That(AnonymousHelper.CanConvert&lt;DummyClosure, DummyAnonymousClosure&gt;(anon), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void CanConvert_ReturnsFalseForMismatchedTypes()&#10;    {&#10;        var anon = new DummyAnonymousClosure&#10;        {&#10;            Context = AnonymousValue.Char('c'),&#10;            Delegate = new Action&lt;string&gt;(_ =&gt; { })&#10;        };&#10;        Assert.That(AnonymousHelper.CanConvert&lt;DummyClosure, DummyAnonymousClosure&gt;(anon), Is.False);&#10;    }&#10;&#10;    [TestCase(typeof(InvalidOperationException), ExpectedResult = false)]&#10;    [TestCase(typeof(InvalidCastException), ExpectedResult = false)]&#10;    [TestCase(typeof(ArgumentException), ExpectedResult = false)]&#10;    [TestCase(typeof(NullReferenceException), ExpectedResult = true)]&#10;    public bool ShouldThrow_Works(Type exceptionType)&#10;    {&#10;        var ex = (Exception)Activator.CreateInstance(exceptionType)!;&#10;        return AnonymousHelper.ShouldThrow(ex);&#10;    }&#10;&#10;    [Test]&#10;    public void IsAction_TrueForAction()&#10;    {&#10;        Action a = () =&gt; { };&#10;        Assert.That(AnonymousHelper.IsAction(a), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void IsAction_FalseForFunc()&#10;    {&#10;        Func&lt;int&gt; f = () =&gt; 1;&#10;        Assert.That(AnonymousHelper.IsAction(f), Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void IsFunc_TrueForFunc()&#10;    {&#10;        Func&lt;int&gt; f = () =&gt; 1;&#10;        Assert.That(AnonymousHelper.IsFunc(f), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void IsFunc_FalseForAction()&#10;    {&#10;        Action a = () =&gt; { };&#10;        Assert.That(AnonymousHelper.IsFunc(a), Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void GetGenericArguments_Delegate_ReturnsCorrectTypes()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        var args = AnonymousHelper.GetGenericArguments(del);&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(string) }));&#10;    }&#10;&#10;    [Test]&#10;    public void GetGenericArguments_Type_ReturnsCorrectTypes()&#10;    {&#10;        var args = AnonymousHelper.GetGenericArguments(typeof(Action&lt;int, string&gt;));&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(string) }));&#10;    }&#10;&#10;    [Test]&#10;    public void HasArgOfType_ReturnsTrueIfArgMatches()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        Assert.That(AnonymousHelper.HasArgOfType&lt;string&gt;(del), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void HasArgOfType_ReturnsFalseIfArgDoesNotMatch()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        Assert.That(AnonymousHelper.HasArgOfType&lt;double&gt;(del), Is.False);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousInvokersTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousInvokersTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousInvokers))]&#10;public class AnonymousInvokersTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;using System;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousInvokers))]&#10;public class AnonymousInvokersTest&#10;{&#10;    [Test]&#10;    public void GetActionInvoker_InvokesNormalAction()&#10;    {&#10;        int called = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; called = ctx + 1;&#10;        var anon = AnonymousValue.From(41);&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Reset);&#10;&#10;        Assert.That(called, Is.EqualTo(42));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(41)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvoker_InvokesMutatingAction()&#10;    {&#10;        Action&lt;ref int&gt; action = (ref int ctx) =&gt; ctx += 10;&#10;        var anon = AnonymousValue.From(5);&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Mutate);&#10;&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(15));&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvokerTArg_InvokesNormalActionWithArg()&#10;    {&#10;        int called = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; called = ctx + arg;&#10;        var anon = AnonymousValue.From(10);&#10;        int arg = 5;&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker&lt;int&gt;(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Reset, ref arg);&#10;&#10;        Assert.That(called, Is.EqualTo(15));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvokerTArg_InvokesMutatingActionWithArg()&#10;    {&#10;        ActionWithRefContext&lt;int, int&gt; action = (ref int ctx, int arg) =&gt; ctx += arg;&#10;        var anon = AnonymousValue.From(7);&#10;        int arg = 3;&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker&lt;int&gt;(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Mutate, ref arg);&#10;&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_InvokesNormalFunc()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx * 2;&#10;        var anon = AnonymousValue.From(21);&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Reset);&#10;&#10;        Assert.That(result, Is.EqualTo(42));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(21)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_InvokesMutatingFunc()&#10;    {&#10;        RefFunc&lt;int, int&gt; func = (ref int ctx) =&gt; ++ctx;&#10;        var anon = AnonymousValue.From(99);&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Mutate);&#10;&#10;        Assert.That(result, Is.EqualTo(100));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(100));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_InvokesNormalFuncWithArg()&#10;    {&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;        var anon = AnonymousValue.From(10);&#10;        int arg = 5;&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int, int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Reset, ref arg);&#10;&#10;        Assert.That(result, Is.EqualTo(15));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_InvokesMutatingFuncWithArg()&#10;    {&#10;        RefFunc&lt;int, int, int&gt; func = (ref int ctx, ref int arg) =&gt; ctx += arg;&#10;        var anon = AnonymousValue.From(3);&#10;        int arg = 4;&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int, int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Mutate, ref arg);&#10;&#10;        Assert.That(result, Is.EqualTo(7));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(7));&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvoker_ThrowsOnInvalidDelegate()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx;&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; AnonymousInvokers.GetActionInvoker(func));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_ThrowsOnInvalidReturnType()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx;&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; AnonymousInvokers.GetFuncInvoker&lt;string&gt;(func));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_ThrowsOnInvalidArgType()&#10;    {&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; AnonymousInvokers.GetFuncInvoker&lt;string, int&gt;(func));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousValueTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousValueTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousValue))]&#10;public class AnonymousValueTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousValue))]&#10;public class AnonymousValueTest&#10;{&#10;    [TestCase('a')]&#10;    [TestCase('Z')]&#10;    public void Char_Roundtrip(char value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;char&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;char&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(char)));&#10;    }&#10;&#10;    [TestCase(true)]&#10;    [TestCase(false)]&#10;    public void Bool_Roundtrip(bool value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;bool&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;bool&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(bool)));&#10;    }&#10;&#10;    [TestCase((byte)1)]&#10;    [TestCase(byte.MaxValue)]&#10;    public void Byte_Roundtrip(byte value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;byte&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;byte&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(byte)));&#10;    }&#10;&#10;    [TestCase((sbyte)-1)]&#10;    [TestCase(sbyte.MaxValue)]&#10;    public void SByte_Roundtrip(sbyte value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;sbyte&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;sbyte&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(sbyte)));&#10;    }&#10;&#10;    [TestCase((short)-123)]&#10;    [TestCase(short.MaxValue)]&#10;    public void Short_Roundtrip(short value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;short&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;short&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(short)));&#10;    }&#10;&#10;    [TestCase((ushort)123)]&#10;    [TestCase(ushort.MaxValue)]&#10;    public void UShort_Roundtrip(ushort value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;ushort&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;ushort&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(ushort)));&#10;    }&#10;&#10;    [TestCase(-123)]&#10;    [TestCase(int.MaxValue)]&#10;    public void Int_Roundtrip(int value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;int&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(int)));&#10;    }&#10;&#10;    [TestCase(uint.MaxValue)]&#10;    [TestCase(123u)]&#10;    public void UInt_Roundtrip(uint value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;uint&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;uint&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(uint)));&#10;    }&#10;&#10;    [TestCase(-123L)]&#10;    [TestCase(long.MaxValue)]&#10;    public void Long_Roundtrip(long value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;long&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;long&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(long)));&#10;    }&#10;&#10;    [TestCase(ulong.MaxValue)]&#10;    [TestCase(123UL)]&#10;    public void ULong_Roundtrip(ulong value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;ulong&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;ulong&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(ulong)));&#10;    }&#10;&#10;    [TestCase(1.23f)]&#10;    [TestCase(float.MaxValue)]&#10;    public void Float_Roundtrip(float value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;float&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;float&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(float)));&#10;    }&#10;&#10;    [TestCase(1.23)]&#10;    [TestCase(double.MaxValue)]&#10;    public void Double_Roundtrip(double value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;double&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;double&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(double)));&#10;    }&#10;&#10;    [TestCase(1.23)]&#10;    [TestCase(123456789.123456789)]&#10;    public void Decimal_Roundtrip(decimal value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;decimal&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;decimal&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(decimal)));&#10;    }&#10;&#10;    [Test]&#10;    public void Reference_Roundtrip()&#10;    {&#10;        var obj = new object();&#10;        var anon = AnonymousValue.From(obj);&#10;        Assert.That(anon.Is&lt;object&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;object&gt;(), Is.SameAs(obj));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(object)));&#10;    }&#10;&#10;    [Test]&#10;    public void Set_UpdatesValueAndType()&#10;    {&#10;        var anon = AnonymousValue.From(1);&#10;        anon.Set(2);&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(2));&#10;        anon.Set(&quot;hello&quot;);&#10;        Assert.That(anon.As&lt;string&gt;(), Is.EqualTo(&quot;hello&quot;));&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_WorksForSameValue()&#10;    {&#10;        var a = AnonymousValue.From(123);&#10;        var b = AnonymousValue.From(123);&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a == b, Is.True);&#10;        Assert.That(a != b, Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_WorksForDifferentValue()&#10;    {&#10;        var a = AnonymousValue.From(123);&#10;        var b = AnonymousValue.From(456);&#10;        Assert.That(a, Is.Not.EqualTo(b));&#10;        Assert.That(a == b, Is.False);&#10;        Assert.That(a != b, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void As_InvalidCast_Throws()&#10;    {&#10;        var anon = AnonymousValue.From(123);&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; anon.As&lt;string&gt;());&#10;    }&#10;&#10;    [Test]&#10;    public void Set_NullReference_Throws()&#10;    {&#10;        var anon = AnonymousValue.From(123);&#10;        Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; anon.Set&lt;object&gt;(null!));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/ResultTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/ResultTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(Result))]&#10;public class ResultTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(Result))]&#10;public class ResultTest&#10;{&#10;    [Test]&#10;    public void Result_Success_CreatesSuccessResult()&#10;    {&#10;        var result = Result.Success();&#10;        Assert.That(result.IsSuccess, Is.True);&#10;        Assert.That(result.Exception, Is.Null);&#10;        Assert.That((bool)result, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void Result_Failure_CreatesFailureResult()&#10;    {&#10;        var ex = new InvalidOperationException(&quot;fail&quot;);&#10;        var result = Result.Failure(ex);&#10;        Assert.That(result.IsSuccess, Is.False);&#10;        Assert.That(result.Exception, Is.EqualTo(ex));&#10;        Assert.That((bool)result, Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void ResultT_Success_CreatesSuccessResult()&#10;    {&#10;        var value = 42;&#10;        var result = Result&lt;int&gt;.Success(value);&#10;        Assert.That(result.IsSuccess, Is.True);&#10;        Assert.That(result.Value, Is.EqualTo(value));&#10;        Assert.That(result.Exception, Is.Null);&#10;        Assert.That((bool)result, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void ResultT_Failure_CreatesFailureResult()&#10;    {&#10;        var ex = new ArgumentException(&quot;fail&quot;);&#10;        var result = Result&lt;string&gt;.Failure(ex);&#10;        Assert.That(result.IsSuccess, Is.False);&#10;        Assert.That(result.Value, Is.Null);&#10;        Assert.That(result.Exception, Is.EqualTo(ex));&#10;        Assert.That((bool)result, Is.False);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/CustomClosureTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/CustomClosureTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(CustomClosure&lt;,&gt;))]&#10;public class CustomClosureTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;using System;&#10;&#10;namespace ClosureTests;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(CustomClosure&lt;,&gt;))]&#10;public class CustomClosureTest&#10;{&#10;    [Test]&#10;    public void CustomClosure_CreatesCorrectly()&#10;    {&#10;        int context = 42;&#10;        Func&lt;int, int&gt; func = x =&gt; x + 1;&#10;        var closure = Closure.Custom(context, func);&#10;&#10;        Assert.That(closure.Context, Is.EqualTo(context));&#10;        Assert.That(closure.Delegate, Is.EqualTo(func));&#10;    }&#10;&#10;    [Test]&#10;    public void CustomClosure_DelegateCanBeInvoked()&#10;    {&#10;        string context = &quot;Hello&quot;;&#10;        Func&lt;string, string, string&gt; func = (ctx, arg) =&gt; $&quot;{ctx}, {arg}!&quot;;&#10;        var closure = Closure.Custom(context, func);&#10;&#10;        // Manually invoke the delegate, passing context as the first argument&#10;        var result = closure.Delegate.Invoke(closure.Context, &quot;World&quot;);&#10;        Assert.That(result, Is.EqualTo(&quot;Hello, World!&quot;));&#10;    }&#10;&#10;    [Test]&#10;    public void CustomClosure_WorksWithAction()&#10;    {&#10;        int context = 10;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx + arg;&#10;        var closure = Closure.Custom(context, action);&#10;&#10;        closure.Delegate.Invoke(closure.Context, 5);&#10;        Assert.That(calledWith, Is.EqualTo(15));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Anonymous/AnonymousClosure.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Anonymous/AnonymousClosure.cs" />
              <option name="originalContent" value="namespace Closures;&#10;&#10;/// &lt;summary&gt;&#10;/// Whether the closure should mutate the context or reset it after invocation.&#10;/// &lt;/summary&gt;&#10;public enum MutatingBehaviour : byte {&#10;    Mutate,&#10;    Reset&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Policy for handling exceptions during delegate invocation.&#10;/// &lt;/summary&gt;&#10;public enum ExceptionHandlingPolicy : byte {&#10;    HandleExpected,&#10;    HandleAll,&#10;    HandleNone&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an Anonymous Closure that encapsulates a delegate and a context.&#10;/// &lt;/summary&gt;&#10;public interface IAnonymousClosure : IClosure&lt;AnonymousValue, Delegate&gt; {&#10;    MutatingBehaviour MutatingBehaviour { get; init; }&#10;    /// &lt;summary&gt;&#10;    /// Determines if this closure can be converted to the specified closure type.&#10;    /// &lt;/summary&gt;&#10;    bool Is&lt;TClosureType&gt;() where TClosureType : IClosure;&#10;}&#10;&#10;// TODO: Use source generators to generate all used delegate types and their invokers&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an anonymous closure that encapsulates a delegate and a context,&#10;/// along with a &lt;see cref=&quot;MutatingBehaviour&quot;/&gt; indicating whether the context should be mutated or reset after invocation.&#10;/// &lt;para&gt;&#10;/// This struct provides a unified, type-erased way to store and invoke closures with arbitrary context and delegate types,&#10;/// supporting both action and function delegates, with or without arguments, and handling mutating or resetting context behaviour.&#10;/// &lt;/para&gt;&#10;/// &lt;/summary&gt;&#10;public partial record struct AnonymousClosure : IAnonymousClosure {&#10;    public Delegate Delegate { get; init; }&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext; &#10;        init =&gt; anonymousContext = value;&#10;    }&#10;    AnonymousValue anonymousContext;&#10;&#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;    &#10;    Delegate? cachedInvoker;&#10;&#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt; &#10;        AnonymousHelper.CanConvert&lt;AnonymousClosure, TClosureType&gt;(this);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    public void Invoke() {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument, and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    public void Invoke&lt;TArg&gt;(TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker&lt;TArg&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker&lt;TArg&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument (by ref), and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    public void Invoke&lt;TArg&gt;(ref TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker&lt;TArg&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker&lt;TArg&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context and mutating behaviour, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke&lt;TReturn&gt;() {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument, and mutating behaviour, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke&lt;TArg, TReturn&gt;(TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TArg, TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TArg, TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument (by ref), and mutating behaviour, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke&lt;TArg, TReturn&gt;(ref TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TArg, TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TArg, TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result TryInvoke(ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke();&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result TryInvoke&lt;TArg&gt;(TArg arg, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke(arg);&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result TryInvoke&lt;TArg&gt;(ref TArg arg, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke(ref arg);&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke&lt;TReturn&gt;(ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke&lt;TReturn&gt;();&#10;            return Result&lt;TReturn&gt;.Success(result!);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke&lt;TArg, TReturn&gt;(TArg arg, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke&lt;TArg, TReturn&gt;(arg);&#10;            return Result&lt;TReturn&gt;.Success(result!);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke&lt;TArg, TReturn&gt;(ref TArg arg, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke&lt;TArg, TReturn&gt;(ref arg);&#10;            return Result&lt;TReturn&gt;.Success(result!);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public bool Equals(AnonymousClosure other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp; MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}" />
              <option name="updatedContent" value="namespace Closures;&#10;&#10;/// &lt;summary&gt;&#10;/// Whether the closure should mutate the context or reset it after invocation.&#10;/// &lt;/summary&gt;&#10;public enum MutatingBehaviour : byte {&#10;    Mutate,&#10;    Reset&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Policy for handling exceptions during delegate invocation.&#10;/// &lt;/summary&gt;&#10;public enum ExceptionHandlingPolicy : byte {&#10;    HandleExpected,&#10;    HandleAll,&#10;    HandleNone&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an Anonymous Closure that encapsulates a delegate and a context.&#10;/// &lt;/summary&gt;&#10;public interface IAnonymousClosure : IClosure&lt;AnonymousValue, Delegate&gt; {&#10;    MutatingBehaviour MutatingBehaviour { get; init; }&#10;    /// &lt;summary&gt;&#10;    /// Determines if this closure can be converted to the specified closure type.&#10;    /// &lt;/summary&gt;&#10;    bool Is&lt;TClosureType&gt;() where TClosureType : IClosure;&#10;}&#10;&#10;// TODO: Use source generators to generate all used delegate types and their invokers&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an anonymous closure that encapsulates a delegate and a context,&#10;/// along with a &lt;see cref=&quot;MutatingBehaviour&quot;/&gt; indicating whether the context should be mutated or reset after invocation.&#10;/// &lt;para&gt;&#10;/// This struct provides a unified, type-erased way to store and invoke closures with arbitrary context and delegate types,&#10;/// supporting both action and function delegates, with or without arguments, and handling mutating or resetting context behaviour.&#10;/// &lt;/para&gt;&#10;/// &lt;/summary&gt;&#10;public partial record struct AnonymousClosure : IAnonymousClosure {&#10;    public Delegate Delegate { get; init; }&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext; &#10;        init =&gt; anonymousContext = value;&#10;    }&#10;    AnonymousValue anonymousContext;&#10;&#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;    &#10;    Delegate? cachedInvoker;&#10;&#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt; &#10;        AnonymousHelper.CanConvert&lt;AnonymousClosure, TClosureType&gt;(this);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    public void Invoke() {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument, and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    public void Invoke&lt;TArg&gt;(TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker&lt;TArg&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker&lt;TArg&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument (by ref), and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    public void Invoke&lt;TArg&gt;(ref TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker&lt;TArg&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker&lt;TArg&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context and mutating behaviour, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke&lt;TReturn&gt;() {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument, and mutating behaviour, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke&lt;TArg, TReturn&gt;(TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TArg, TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TArg, TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument (by ref), and mutating behaviour, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke&lt;TArg, TReturn&gt;(ref TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TArg, TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TArg, TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result TryInvoke(ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke();&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result TryInvoke&lt;TArg&gt;(TArg arg, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke(arg);&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result TryInvoke&lt;TArg&gt;(ref TArg arg, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke(ref arg);&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke&lt;TReturn&gt;(ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke&lt;TReturn&gt;();&#10;            return Result&lt;TReturn&gt;.Success(result!);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke&lt;TArg, TReturn&gt;(TArg arg, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke&lt;TArg, TReturn&gt;(arg);&#10;            return Result&lt;TReturn&gt;.Success(result!);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;, returning a value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke&lt;TArg, TReturn&gt;(ref TArg arg, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke&lt;TArg, TReturn&gt;(ref arg);&#10;            return Result&lt;TReturn&gt;.Success(result!);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy))&#10;                throw;&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public bool Equals(AnonymousClosure other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp; MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Anonymous/AnonymousClosureAction.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Anonymous/AnonymousClosureAction.cs" />
              <option name="originalContent" value="namespace Closures;&#10;&#10;public record struct AnonymousClosureAction : IClosureAction&lt;AnonymousValue, Delegate&gt;, IAnonymousClosure {&#10;    public Delegate Delegate { get; init; }&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext; &#10;        init =&gt; anonymousContext = value;&#10;    }&#10;    AnonymousValue anonymousContext;&#10;&#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;    &#10;    Delegate? cachedInvoker;&#10;&#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt; &#10;        AnonymousHelper.CanConvert&lt;AnonymousClosureAction, TClosureType&gt;(this);&#10;    &#10;    public void Invoke() {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour);&#10;    }&#10;&#10;    public Result TryInvoke(ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke();&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;    &#10;    public bool Equals(AnonymousClosureAction other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp; MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}&#10;&#10;public record struct AnonymousClosureAction&lt;TArg&gt; : IClosureRefAction&lt;AnonymousValue, TArg, Delegate&gt;, IAnonymousClosure {&#10;    public Delegate Delegate { get; init; }&#10;&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext;&#10;        init =&gt; anonymousContext = value;&#10;    }&#10;&#10;    AnonymousValue anonymousContext;&#10;&#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;&#10;    Delegate? cachedInvoker;&#10;&#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt;&#10;        AnonymousHelper.CanConvert&lt;AnonymousClosureAction&lt;TArg&gt;, TClosureType&gt;(this);&#10;&#10;    public void Invoke(TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker&lt;TArg&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker&lt;TArg&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    public void Invoke(ref TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker&lt;TArg&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker&lt;TArg&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    public Result TryInvoke(TArg arg,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke(arg);&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;&#10;    public Result TryInvoke(ref TArg arg,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke(ref arg);&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;&#10;    public bool Equals(AnonymousClosureAction&lt;TArg&gt; other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp;&#10;               MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}" />
              <option name="updatedContent" value="namespace Closures;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an anonymous closure that encapsulates a delegate with no arguments and no return value,&#10;/// along with an &lt;see cref=&quot;AnonymousValue&quot;/&gt; context and mutating behaviour.&#10;/// &lt;/summary&gt;&#10;public record struct AnonymousClosureAction : IClosureAction&lt;AnonymousValue, Delegate&gt;, IAnonymousClosure {&#10;    /// &lt;summary&gt;&#10;    /// The delegate to invoke.&#10;    /// &lt;/summary&gt;&#10;    public Delegate Delegate { get; init; }&#10;    /// &lt;summary&gt;&#10;    /// The captured context for the closure.&#10;    /// &lt;/summary&gt;&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext; &#10;        init =&gt; anonymousContext = value;&#10;    }&#10;    AnonymousValue anonymousContext;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Specifies whether the context should be mutated or reset after invocation.&#10;    /// &lt;/summary&gt;&#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;    &#10;    Delegate? cachedInvoker;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Determines if this closure can be converted to the specified closure type.&#10;    /// &lt;/summary&gt;&#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt; &#10;        AnonymousHelper.CanConvert&lt;AnonymousClosureAction, TClosureType&gt;(this);&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    public void Invoke() {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified policy.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    public Result TryInvoke(ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke();&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;    &#10;    /// &lt;inheritdoc/&gt;&#10;    public bool Equals(AnonymousClosureAction other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp; MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an anonymous closure that encapsulates a delegate with a single argument and no return value,&#10;/// along with an &lt;see cref=&quot;AnonymousValue&quot;/&gt; context and mutating behaviour.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;public record struct AnonymousClosureAction&lt;TArg&gt; : IClosureRefAction&lt;AnonymousValue, TArg, Delegate&gt;, IAnonymousClosure {&#10;    /// &lt;summary&gt;&#10;    /// The delegate to invoke.&#10;    /// &lt;/summary&gt;&#10;    public Delegate Delegate { get; init; }&#10;&#10;    /// &lt;summary&gt;&#10;    /// The captured context for the closure.&#10;    /// &lt;/summary&gt;&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext;&#10;        init =&gt; anonymousContext = value;&#10;    }&#10;&#10;    AnonymousValue anonymousContext;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Specifies whether the context should be mutated or reset after invocation.&#10;    /// &lt;/summary&gt;&#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;&#10;    Delegate? cachedInvoker;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Determines if this closure can be converted to the specified closure type.&#10;    /// &lt;/summary&gt;&#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt;&#10;        AnonymousHelper.CanConvert&lt;AnonymousClosureAction&lt;TArg&gt;, TClosureType&gt;(this);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument, and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    public void Invoke(TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker&lt;TArg&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker&lt;TArg&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument (by ref), and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    public void Invoke(ref TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.ActionInvoker&lt;TArg&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetActionInvoker&lt;TArg&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;&#10;        invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified policy.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    public Result TryInvoke(TArg arg,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke(arg);&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified policy.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    public Result TryInvoke(ref TArg arg,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            Invoke(ref arg);&#10;            return Result.Success();&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result.Failure(e);&#10;        }&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public bool Equals(AnonymousClosureAction&lt;TArg&gt; other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp;&#10;               MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Anonymous/AnonymousClosureFunc.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Anonymous/AnonymousClosureFunc.cs" />
              <option name="originalContent" value="namespace Closures;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an anonymous closure that encapsulates a delegate with no arguments and a return value,&#10;/// along with an &lt;see cref=&quot;AnonymousValue&quot;/&gt; context and &lt;see cref=&quot;MutatingBehaviour&quot;/&gt;.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;public record struct AnonymousClosureFunc&lt;TReturn&gt; : IClosureFunc&lt;AnonymousValue, TReturn, Delegate&gt;, IAnonymousClosure {&#10;    public Delegate Delegate { get; init; }&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext; &#10;        init =&gt; anonymousContext = value;&#10;    }&#10;    AnonymousValue anonymousContext;&#10;    &#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;    &#10;    Delegate? cachedInvoker;&#10;    &#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt; &#10;        AnonymousHelper.CanConvert&lt;AnonymousClosureFunc&lt;TReturn&gt;, TClosureType&gt;(this);&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke() {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;returnValue&quot;&gt;The return value from the delegate if successful; otherwise, default.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if invocation succeeded; otherwise, false.&lt;/returns&gt;&#10;    public bool TryInvoke(out TReturn returnValue, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            returnValue = Invoke();&#10;            return true;&#10;        }&#10;        catch (Exception e) {&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;            &#10;            returnValue = default!;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke(ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke();&#10;            return Result&lt;TReturn&gt;.Success(result);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;    &#10;    /// &lt;inheritdoc/&gt;&#10;    public bool Equals(AnonymousClosureFunc&lt;TReturn&gt; other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp; MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an anonymous closure that encapsulates a delegate with a single argument and a return value,&#10;/// along with an &lt;see cref=&quot;AnonymousValue&quot;/&gt; context and &lt;see cref=&quot;MutatingBehaviour&quot;/&gt;.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;/// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;public record struct AnonymousClosureFunc&lt;TArg, TReturn&gt; : IClosureRefFunc&lt;AnonymousValue, TArg, TReturn, Delegate&gt;, IAnonymousClosure {&#10;    public Delegate Delegate { get; init; }&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext;&#10;        init =&gt; anonymousContext = value;&#10;    }&#10;&#10;    AnonymousValue anonymousContext;&#10;    &#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;&#10;    Delegate? cachedInvoker;&#10;    &#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt;&#10;        AnonymousHelper.CanConvert&lt;AnonymousClosureFunc&lt;TArg, TReturn&gt;, TClosureType&gt;(this);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument, and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke(TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TArg, TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TArg, TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument (by ref), and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke(ref TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TArg, TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TArg, TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;returnValue&quot;&gt;The return value from the delegate if successful; otherwise, default.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if invocation succeeded; otherwise, false.&lt;/returns&gt;&#10;    public bool TryInvoke(TArg arg, out TReturn returnValue,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            returnValue = Invoke(arg);&#10;            return true;&#10;        }&#10;        catch (Exception e) {&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            returnValue = default!;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke(TArg arg,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke(ref arg);&#10;            return Result&lt;TReturn&gt;.Success(result);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;returnValue&quot;&gt;The return value from the delegate if successful; otherwise, default.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if invocation succeeded; otherwise, false.&lt;/returns&gt;&#10;    public bool TryInvoke(ref TArg arg, out TReturn returnValue,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            returnValue = Invoke(arg);&#10;            return true;&#10;        }&#10;        catch (Exception e) {&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            returnValue = default!;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke(ref TArg arg,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke(ref arg);&#10;            return Result&lt;TReturn&gt;.Success(result);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public bool Equals(AnonymousClosureFunc&lt;TArg, TReturn&gt; other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp;&#10;               MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}" />
              <option name="updatedContent" value="namespace Closures;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an anonymous closure that encapsulates a delegate with no arguments and a return value,&#10;/// along with an &lt;see cref=&quot;AnonymousValue&quot;/&gt; context and &lt;see cref=&quot;MutatingBehaviour&quot;/&gt;.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;public record struct AnonymousClosureFunc&lt;TReturn&gt; : IClosureFunc&lt;AnonymousValue, TReturn, Delegate&gt;, IAnonymousClosure {&#10;    public Delegate Delegate { get; init; }&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext; &#10;        init =&gt; anonymousContext = value;&#10;    }&#10;    AnonymousValue anonymousContext;&#10;    &#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;    &#10;    Delegate? cachedInvoker;&#10;    &#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt; &#10;        AnonymousHelper.CanConvert&lt;AnonymousClosureFunc&lt;TReturn&gt;, TClosureType&gt;(this);&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke() {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;returnValue&quot;&gt;The return value from the delegate if successful; otherwise, default.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if invocation succeeded; otherwise, false.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public bool TryInvoke(out TReturn returnValue, ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            returnValue = Invoke();&#10;            return true;&#10;        }&#10;        catch (Exception e) {&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;            &#10;            returnValue = default!;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke(ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke();&#10;            return Result&lt;TReturn&gt;.Success(result);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;    &#10;    /// &lt;inheritdoc/&gt;&#10;    public bool Equals(AnonymousClosureFunc&lt;TReturn&gt; other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp; MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Represents an anonymous closure that encapsulates a delegate with a single argument and a return value,&#10;/// along with an &lt;see cref=&quot;AnonymousValue&quot;/&gt; context and &lt;see cref=&quot;MutatingBehaviour&quot;/&gt;.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument passed to the delegate.&lt;/typeparam&gt;&#10;/// &lt;typeparam name=&quot;TReturn&quot;&gt;The return type of the delegate.&lt;/typeparam&gt;&#10;public record struct AnonymousClosureFunc&lt;TArg, TReturn&gt; : IClosureRefFunc&lt;AnonymousValue, TArg, TReturn, Delegate&gt;, IAnonymousClosure {&#10;    public Delegate Delegate { get; init; }&#10;    public AnonymousValue Context {&#10;        get =&gt; anonymousContext;&#10;        init =&gt; anonymousContext = value;&#10;    }&#10;&#10;    AnonymousValue anonymousContext;&#10;    &#10;    public MutatingBehaviour MutatingBehaviour { get; init; }&#10;&#10;    Delegate? cachedInvoker;&#10;    &#10;    public bool Is&lt;TClosureType&gt;() where TClosureType : IClosure =&gt;&#10;        AnonymousHelper.CanConvert&lt;AnonymousClosureFunc&lt;TArg, TReturn&gt;, TClosureType&gt;(this);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument, and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke(TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TArg, TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TArg, TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Invokes the encapsulated delegate with the current context, argument (by ref), and mutating behaviour.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;returns&gt;The return value from the delegate.&lt;/returns&gt;&#10;    public TReturn Invoke(ref TArg arg) {&#10;        if (cachedInvoker is not AnonymousInvokers.FuncInvoker&lt;TArg, TReturn&gt; invoker) {&#10;            invoker = AnonymousInvokers.GetFuncInvoker&lt;TArg, TReturn&gt;(Delegate);&#10;            cachedInvoker = invoker;&#10;        }&#10;&#10;        return invoker.Invoke(Delegate, ref anonymousContext, MutatingBehaviour, ref arg);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;returnValue&quot;&gt;The return value from the delegate if successful; otherwise, default.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if invocation succeeded; otherwise, false.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public bool TryInvoke(TArg arg, out TReturn returnValue,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            returnValue = Invoke(arg);&#10;            return true;&#10;        }&#10;        catch (Exception e) {&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            returnValue = default!;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument, handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke(TArg arg,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke(ref arg);&#10;            return Result&lt;TReturn&gt;.Success(result);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;returnValue&quot;&gt;The return value from the delegate if successful; otherwise, default.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if invocation succeeded; otherwise, false.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public bool TryInvoke(ref TArg arg, out TReturn returnValue,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            returnValue = Invoke(arg);&#10;            return true;&#10;        }&#10;        catch (Exception e) {&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            returnValue = default!;&#10;            return false;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Attempts to invoke the delegate with the specified argument (by ref), handling exceptions according to the specified &lt;see cref=&quot;ExceptionHandlingPolicy&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;arg&quot;&gt;The argument to pass to the delegate by reference.&lt;/param&gt;&#10;    /// &lt;param name=&quot;exceptionHandlingPolicy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;A &lt;see cref=&quot;Result{TReturn}&quot;/&gt; indicating success or failure.&lt;/returns&gt;&#10;    /// &lt;remarks&gt;&#10;    /// Exceptions thrown within the delegate invocation should be handled during invocation,&#10;    /// the exception handling here is for incorrect delegate types.&#10;    /// &lt;/remarks&gt;&#10;    public Result&lt;TReturn&gt; TryInvoke(ref TArg arg,&#10;        ExceptionHandlingPolicy exceptionHandlingPolicy = ExceptionHandlingPolicy.HandleExpected) {&#10;        try {&#10;            var result = Invoke(ref arg);&#10;            return Result&lt;TReturn&gt;.Success(result);&#10;        }&#10;        catch (Exception e) {&#10;            // Ignore exceptions that are expected from delegate invocation&#10;            if (AnonymousHelper.ShouldThrow(e, exceptionHandlingPolicy)) {&#10;                throw;&#10;            }&#10;&#10;            return Result&lt;TReturn&gt;.Failure(e);&#10;        }&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public bool Equals(AnonymousClosureFunc&lt;TArg, TReturn&gt; other) {&#10;        return anonymousContext.Equals(other.anonymousContext) &amp;&amp; Delegate.Equals(other.Delegate) &amp;&amp;&#10;               MutatingBehaviour == other.MutatingBehaviour;&#10;    }&#10;&#10;    /// &lt;inheritdoc/&gt;&#10;    public override int GetHashCode() {&#10;        return HashCode.Combine(anonymousContext, Delegate, (int)MutatingBehaviour);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Anonymous/AnonymousHelper.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Anonymous/AnonymousHelper.cs" />
              <option name="originalContent" value="using System.Collections.Concurrent;&#10;using System.Runtime.CompilerServices;&#10;&#10;namespace Closures;&#10;&#10;/// &lt;summary&gt;&#10;/// Provides utility methods for working with anonymous closures.&#10;/// &lt;/summary&gt;&#10;public static class AnonymousHelper {&#10;    static readonly ConcurrentDictionary&lt;Type, Type&gt; s_closureTypeToInterfaceTypeMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, Type[]&gt; s_interfaceTypeToGenericArgumentsMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, Type[]&gt; s_delegateTypeToGenericArgumentsMap = new ();&#10;    &#10;    public static Type GetInterfaceType&lt;TClosureType&gt;() where TClosureType : IClosure {&#10;        return s_closureTypeToInterfaceTypeMap.GetOrAdd(typeof(TClosureType), type =&gt; {&#10;            var interfaceType = type.GetInterfaces()&#10;                .FirstOrDefault(i =&gt; i.IsGenericType &amp;&amp; i.GetGenericTypeDefinition() == typeof(IClosure&lt;,&gt;));&#10;&#10;            if (interfaceType is null)&#10;                throw new InvalidOperationException(&#10;                    $&quot;The type {typeof(TClosureType).Name} does not implement IClosure&lt;&gt; interface.&quot;);&#10;&#10;            return interfaceType;&#10;        });&#10;    }&#10;    &#10;    public static Type[] GetInterfaceGenericArguments(Type interfaceType) {&#10;        return s_interfaceTypeToGenericArgumentsMap.GetOrAdd(interfaceType, type =&gt; type.GetGenericArguments());&#10;    }&#10;&#10;    public static bool CanConvert&lt;TFrom, TTo&gt;(TFrom closure) where TTo : IClosure where TFrom : IAnonymousClosure {&#10;        var anonymousContextType = closure.Context.GetUnderlyingType();&#10;        var anonymousDelegateType = closure.Delegate.GetType();&#10;        var conversionInterfaceType = GetInterfaceType&lt;TTo&gt;();&#10;        var genericArguments = GetInterfaceGenericArguments(conversionInterfaceType);&#10;        &#10;        return (genericArguments[0] == anonymousContextType || genericArguments[0] == typeof(AnonymousValue))&#10;               &amp;&amp; genericArguments[1] == anonymousDelegateType;&#10;    }&#10;    &#10;    [MethodImpl(MethodImplOptions.AggressiveInlining)]&#10;    public static bool ShouldThrow(Exception ex, ExceptionHandlingPolicy policy) {&#10;        return policy switch {&#10;            ExceptionHandlingPolicy.HandleExpected =&gt; &#10;                ex is not (InvalidOperationException or InvalidCastException or ArgumentException),&#10;            ExceptionHandlingPolicy.HandleAll =&gt; true,&#10;            ExceptionHandlingPolicy.HandleNone =&gt; false,&#10;            _ =&gt; throw new ArgumentOutOfRangeException(nameof(policy), policy, null)&#10;        };&#10;    }&#10;    &#10;    [MethodImpl(MethodImplOptions.AggressiveInlining)]&#10;    public static bool IsAction(Delegate del) =&gt; del.Method.ReturnType == typeof(void);&#10;    &#10;    [MethodImpl(MethodImplOptions.AggressiveInlining)]&#10;    public static bool IsFunc(Delegate del) =&gt; del.Method.ReturnType != typeof(void);&#10;    &#10;    public static Type[] GetGenericArguments(Delegate @delegate) {&#10;        return GetGenericArguments(@delegate.GetType());&#10;    }&#10;    public static Type[] GetGenericArguments(Type delegateType) {&#10;        return s_delegateTypeToGenericArgumentsMap.GetOrAdd(delegateType, type =&gt; type.GetGenericArguments());&#10;    }&#10;    &#10;    public static bool HasArg(Delegate del) { &#10;        var genericArguments = GetGenericArguments(del);&#10;        return IsAction(del) ? genericArguments.Length &gt; 1 : genericArguments.Length &gt; 2;&#10;    }&#10;    public static bool HasArgOfType&lt;TArg&gt;(Delegate del) {&#10;        var genericArguments = GetGenericArguments(del);&#10;        return IsAction(del) &#10;            ? genericArguments.Length &gt; 1 &amp;&amp; genericArguments[1] == typeof(TArg) &#10;            : genericArguments.Length &gt; 2 &amp;&amp; genericArguments[1] == typeof(TArg);&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections.Concurrent;&#10;using System.Runtime.CompilerServices;&#10;&#10;namespace Closures;&#10;&#10;/// &lt;summary&gt;&#10;/// Provides utility methods for working with anonymous closures.&#10;/// &lt;/summary&gt;&#10;public static class AnonymousHelper {&#10;    static readonly ConcurrentDictionary&lt;Type, Type&gt; s_closureTypeToInterfaceTypeMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, Type[]&gt; s_interfaceTypeToGenericArgumentsMap = new ();&#10;    static readonly ConcurrentDictionary&lt;Type, Type[]&gt; s_delegateTypeToGenericArgumentsMap = new ();&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the &lt;see cref=&quot;IClosure{TContext,TDelegate}&quot;/&gt; interface implemented by the specified closure type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TClosureType&quot;&gt;The closure type.&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The interface type implemented by the closure.&lt;/returns&gt;&#10;    /// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;Thrown if the type does not implement &lt;see cref=&quot;IClosure{,}&quot;/&gt;.&lt;/exception&gt;&#10;    public static Type GetInterfaceType&lt;TClosureType&gt;() where TClosureType : IClosure {&#10;        return s_closureTypeToInterfaceTypeMap.GetOrAdd(typeof(TClosureType), type =&gt; {&#10;            var interfaceType = type.GetInterfaces()&#10;                .FirstOrDefault(i =&gt; i.IsGenericType &amp;&amp; i.GetGenericTypeDefinition() == typeof(IClosure&lt;,&gt;));&#10;&#10;            if (interfaceType is null)&#10;                throw new InvalidOperationException(&#10;                    $&quot;The type {typeof(TClosureType).Name} does not implement IClosure&lt;&gt; interface.&quot;);&#10;&#10;            return interfaceType;&#10;        });&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the generic arguments of the specified closure interface type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;interfaceType&quot;&gt;The closure interface type.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetInterfaceGenericArguments(Type interfaceType) {&#10;        return s_interfaceTypeToGenericArgumentsMap.GetOrAdd(interfaceType, type =&gt; type.GetGenericArguments());&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Determines if an anonymous closure can be converted to a strongly-typed closure.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TFrom&quot;&gt;The anonymous closure type.&lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TTo&quot;&gt;The strongly-typed closure type.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;closure&quot;&gt;The anonymous closure instance.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the conversion is possible; otherwise, false.&lt;/returns&gt;&#10;    public static bool CanConvert&lt;TFrom, TTo&gt;(TFrom closure) where TTo : IClosure where TFrom : IAnonymousClosure {&#10;        var anonymousContextType = closure.Context.GetUnderlyingType();&#10;        var anonymousDelegateType = closure.Delegate.GetType();&#10;        var conversionInterfaceType = GetInterfaceType&lt;TTo&gt;();&#10;        var genericArguments = GetInterfaceGenericArguments(conversionInterfaceType);&#10;        &#10;        return (genericArguments[0] == anonymousContextType || genericArguments[0] == typeof(AnonymousValue))&#10;               &amp;&amp; genericArguments[1] == anonymousDelegateType;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether an exception should be thrown based on the specified exception handling policy.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception to evaluate.&lt;/param&gt;&#10;    /// &lt;param name=&quot;policy&quot;&gt;The exception handling policy.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the exception should be thrown; otherwise, false.&lt;/returns&gt;&#10;    public static bool ShouldThrow(Exception ex, ExceptionHandlingPolicy policy) {&#10;        return policy switch {&#10;            ExceptionHandlingPolicy.HandleExpected =&gt; &#10;                ex is not (InvalidOperationException or InvalidCastException or ArgumentException),&#10;            ExceptionHandlingPolicy.HandleAll =&gt; true,&#10;            ExceptionHandlingPolicy.HandleNone =&gt; false,&#10;            _ =&gt; throw new ArgumentOutOfRangeException(nameof(policy), policy, null)&#10;        };&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate is an action (returns void).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate is an action; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsAction(Delegate del) =&gt; del.Method.ReturnType == typeof(void);&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate is a function (returns a value).&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate is a function; otherwise, false.&lt;/returns&gt;&#10;    public static bool IsFunc(Delegate del) =&gt; del.Method.ReturnType != typeof(void);&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Gets the generic argument types of the specified delegate instance.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegate&quot;&gt;The delegate instance.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetGenericArguments(Delegate @delegate) {&#10;        return GetGenericArguments(@delegate.GetType());&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Gets the generic argument types of the specified delegate type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;delegateType&quot;&gt;The delegate type.&lt;/param&gt;&#10;    /// &lt;returns&gt;An array of generic argument types.&lt;/returns&gt;&#10;    public static Type[] GetGenericArguments(Type delegateType) {&#10;        return s_delegateTypeToGenericArgumentsMap.GetOrAdd(delegateType, type =&gt; type.GetGenericArguments());&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate has at least one argument.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate has at least one argument; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArg(Delegate del) { &#10;        var genericArguments = GetGenericArguments(del);&#10;        return IsAction(del) ? genericArguments.Length &gt; 1 : genericArguments.Length &gt; 2;&#10;    }&#10;    /// &lt;summary&gt;&#10;    /// Determines whether the specified delegate has an argument of the given type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TArg&quot;&gt;The argument type to check for.&lt;/typeparam&gt;&#10;    /// &lt;param name=&quot;del&quot;&gt;The delegate to check.&lt;/param&gt;&#10;    /// &lt;returns&gt;True if the delegate has an argument of the specified type; otherwise, false.&lt;/returns&gt;&#10;    public static bool HasArgOfType&lt;TArg&gt;(Delegate del) {&#10;        var genericArguments = GetGenericArguments(del);&#10;        return IsAction(del) &#10;            ? genericArguments.Length &gt; 1 &amp;&amp; genericArguments[1] == typeof(TArg) &#10;            : genericArguments.Length &gt; 2 &amp;&amp; genericArguments[1] == typeof(TArg);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Anonymous/AnonymousValue.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Anonymous/AnonymousValue.cs" />
              <option name="originalContent" value="using System.Runtime.CompilerServices;&#10;using System.Runtime.InteropServices;&#10;&#10;namespace Closures;&#10;&#10;internal enum ValueType {&#10;    Reference,&#10;&#10;    Char,&#10;    Bool,&#10;&#10;    Byte,&#10;    SByte,&#10;    Short,&#10;    UShort,&#10;    Int,&#10;    UInt,&#10;    Long,&#10;    ULong,&#10;&#10;    Float,&#10;    Double,&#10;    Decimal,&#10;}&#10;&#10;internal static class ValueTypeExtensions {&#10;    public static bool IsOrReference&lt;T&gt;(this ValueType valueType) {&#10;        return valueType switch {&#10;            ValueType.Char =&gt; typeof(T) == typeof(char),&#10;            ValueType.Bool =&gt; typeof(T) == typeof(bool),&#10;&#10;            ValueType.Byte =&gt; typeof(T) == typeof(byte),&#10;            ValueType.SByte =&gt; typeof(T) == typeof(sbyte),&#10;            ValueType.Short =&gt; typeof(T) == typeof(short),&#10;            ValueType.UShort =&gt; typeof(T) == typeof(ushort),&#10;            ValueType.Int =&gt; typeof(T) == typeof(int),&#10;            ValueType.UInt =&gt; typeof(T) == typeof(uint),&#10;            ValueType.Long =&gt; typeof(T) == typeof(long),&#10;            ValueType.ULong =&gt; typeof(T) == typeof(ulong),&#10;&#10;            ValueType.Float =&gt; typeof(T) == typeof(float),&#10;            ValueType.Double =&gt; typeof(T) == typeof(double),&#10;            ValueType.Decimal =&gt; typeof(T) == typeof(decimal),&#10;&#10;            ValueType.Reference =&gt; true,&#10;            _ =&gt; false&#10;        };&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// A struct that can hold any value or reference type.&#10;/// &lt;/summary&gt;&#10;[StructLayout(LayoutKind.Explicit)]&#10;public struct AnonymousValue : IEquatable&lt;AnonymousValue&gt; {&#10;    [FieldOffset(0)] ValueType ValueType;&#10;&#10;    [FieldOffset(8)] object? unknownValue;&#10;&#10;    [FieldOffset(16)] char charValue;&#10;    [FieldOffset(16)] bool boolValue;&#10;&#10;    [FieldOffset(16)] byte byteValue;&#10;    [FieldOffset(16)] sbyte sbyteValue;&#10;    [FieldOffset(16)] short shortValue;&#10;    [FieldOffset(16)] ushort ushortValue;&#10;    [FieldOffset(16)] int intValue;&#10;    [FieldOffset(16)] uint uintValue;&#10;    [FieldOffset(16)] long longValue;&#10;    [FieldOffset(16)] ulong ulongValue;&#10;&#10;    [FieldOffset(16)] float floatValue;&#10;    [FieldOffset(16)] double doubleValue;&#10;    [FieldOffset(16)] decimal decimalValue;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates an AnonymousValue from a value of any type.&#10;    /// The type must be a value type or a reference type that is not null.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to create from&lt;/param&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;Type of the value&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    public static AnonymousValue From&lt;T&gt;(T value) where T : notnull {&#10;        return typeof(T) switch {&#10;            { } t when t == typeof(char) =&gt; Char(Unsafe.As&lt;T, char&gt;(ref value)),&#10;            { } t when t == typeof(bool) =&gt; Bool(Unsafe.As&lt;T, bool&gt;(ref value)),&#10;&#10;            { } t when t == typeof(byte) =&gt; Byte(Unsafe.As&lt;T, byte&gt;(ref value)),&#10;            { } t when t == typeof(sbyte) =&gt; SByte(Unsafe.As&lt;T, sbyte&gt;(ref value)),&#10;            { } t when t == typeof(short) =&gt; Short(Unsafe.As&lt;T, short&gt;(ref value)),&#10;            { } t when t == typeof(ushort) =&gt; UShort(Unsafe.As&lt;T, ushort&gt;(ref value)),&#10;            { } t when t == typeof(int) =&gt; Int(Unsafe.As&lt;T, int&gt;(ref value)),&#10;            { } t when t == typeof(uint) =&gt; UInt(Unsafe.As&lt;T, uint&gt;(ref value)),&#10;            { } t when t == typeof(long) =&gt; Long(Unsafe.As&lt;T, long&gt;(ref value)),&#10;            { } t when t == typeof(ulong) =&gt; ULong(Unsafe.As&lt;T, ulong&gt;(ref value)),&#10;&#10;            { } t when t == typeof(float) =&gt; Float(Unsafe.As&lt;T, float&gt;(ref value)),&#10;            { } t when t == typeof(double) =&gt; Double(Unsafe.As&lt;T, double&gt;(ref value)),&#10;            { } t when t == typeof(decimal) =&gt; Decimal(Unsafe.As&lt;T, decimal&gt;(ref value)),&#10;&#10;            _ =&gt; Unknown(value)&#10;        };&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Checks if the current AnonymousValue is of a specific type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type to check against&lt;/typeparam&gt;&#10;    public bool Is&lt;T&gt;() =&gt; typeof(T) == GetUnderlyingType();&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Returns the value as the specified type &lt;typeparamref name=&quot;T&quot;/&gt; if possible.&#10;    /// Throws &lt;see cref=&quot;InvalidCastException&quot;/&gt; if the type does not match.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type to cast to&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The value as type &lt;typeparamref name=&quot;T&quot;/&gt;&lt;/returns&gt;&#10;    public T As&lt;T&gt;() {&#10;        if (ValueType.IsOrReference&lt;T&gt;()) {&#10;            return ValueType switch {&#10;                ValueType.Char =&gt; Unsafe.As&lt;char, T&gt;(ref charValue),&#10;                ValueType.Bool =&gt; Unsafe.As&lt;bool, T&gt;(ref boolValue),&#10;&#10;                ValueType.Byte =&gt; Unsafe.As&lt;byte, T&gt;(ref byteValue),&#10;                ValueType.SByte =&gt; Unsafe.As&lt;sbyte, T&gt;(ref sbyteValue),&#10;                ValueType.Short =&gt; Unsafe.As&lt;short, T&gt;(ref shortValue),&#10;                ValueType.UShort =&gt; Unsafe.As&lt;ushort, T&gt;(ref ushortValue),&#10;                ValueType.Int =&gt; Unsafe.As&lt;int, T&gt;(ref intValue),&#10;                ValueType.UInt =&gt; Unsafe.As&lt;uint, T&gt;(ref uintValue),&#10;                ValueType.Long =&gt; Unsafe.As&lt;long, T&gt;(ref longValue),&#10;&#10;                ValueType.ULong =&gt; Unsafe.As&lt;ulong, T&gt;(ref ulongValue),&#10;&#10;                ValueType.Float =&gt; Unsafe.As&lt;float, T&gt;(ref floatValue),&#10;                ValueType.Double =&gt; Unsafe.As&lt;double, T&gt;(ref doubleValue),&#10;                ValueType.Decimal =&gt; Unsafe.As&lt;decimal, T&gt;(ref decimalValue),&#10;&#10;                ValueType.Reference =&gt; unknownValue switch {&#10;                    T t =&gt; t,&#10;                    null =&gt; throw new ArgumentNullException(nameof(unknownValue)),&#10;                    _ =&gt; InvalidCast()&#10;                },&#10;                _ =&gt; InvalidCast()&#10;            };&#10;        }&#10;&#10;        return InvalidCast();&#10;&#10;        T InvalidCast() =&gt; throw new InvalidCastException($&quot;Cannot cast AnonymousValue to {typeof(T).Name}.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Sets the value of this &lt;see cref=&quot;AnonymousValue&quot;/&gt; to the specified value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to set.&lt;/param&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the value.&lt;/typeparam&gt;&#10;    public void SetValue&lt;T&gt;(T value) {&#10;        switch (value) {&#10;            case char c:&#10;                charValue = c;&#10;                ValueType = ValueType.Char;&#10;                return;&#10;            case bool b:&#10;                boolValue = b;&#10;                ValueType = ValueType.Bool;&#10;                return;&#10;&#10;            case byte b:&#10;                byteValue = b;&#10;                ValueType = ValueType.Byte;&#10;                return;&#10;            case sbyte sb:&#10;                sbyteValue = sb;&#10;                ValueType = ValueType.SByte;&#10;                return;&#10;            case short s:&#10;                shortValue = s;&#10;                ValueType = ValueType.Short;&#10;                return;&#10;            case ushort us:&#10;                ushortValue = us;&#10;                ValueType = ValueType.UShort;&#10;                return;&#10;            case int i:&#10;                intValue = i;&#10;                ValueType = ValueType.Int;&#10;                return;&#10;            case uint ui:&#10;                uintValue = ui;&#10;                ValueType = ValueType.UInt;&#10;                return;&#10;            case long l:&#10;                longValue = l;&#10;                ValueType = ValueType.Long;&#10;                return;&#10;            case ulong ul:&#10;                ulongValue = ul;&#10;                ValueType = ValueType.ULong;&#10;                return;&#10;&#10;            case float f:&#10;                floatValue = f;&#10;                ValueType = ValueType.Float;&#10;                return;&#10;            case double d:&#10;                doubleValue = d;&#10;                ValueType = ValueType.Double;&#10;                return;&#10;            case decimal dec:&#10;                decimalValue = dec;&#10;                ValueType = ValueType.Decimal;&#10;                return;&#10;&#10;            default:&#10;                unknownValue = value ??&#10;                               throw new ArgumentNullException(nameof(value),&#10;                                   &quot;Cannot set null value to AnonymousValue.&quot;);&#10;                ValueType = ValueType.Reference;&#10;                return;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the underlying type of the value stored in this &lt;see cref=&quot;AnonymousValue&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The &lt;see cref=&quot;Type&quot;/&gt; of the stored value, or null if unknown.&lt;/returns&gt;&#10;    public Type GetUnderlyingType() {&#10;        return ValueType switch {&#10;            ValueType.Char =&gt; typeof(char),&#10;            ValueType.Bool =&gt; typeof(bool),&#10;&#10;            ValueType.Byte =&gt; typeof(byte),&#10;            ValueType.SByte =&gt; typeof(sbyte),&#10;            ValueType.Short =&gt; typeof(short),&#10;            ValueType.UShort =&gt; typeof(ushort),&#10;            ValueType.Int =&gt; typeof(int),&#10;            ValueType.UInt =&gt; typeof(uint),&#10;            ValueType.Long =&gt; typeof(long),&#10;            ValueType.ULong =&gt; typeof(ulong),&#10;&#10;            ValueType.Float =&gt; typeof(float),&#10;            ValueType.Double =&gt; typeof(double),&#10;            ValueType.Decimal =&gt; typeof(decimal),&#10;&#10;            ValueType.Reference =&gt; unknownValue switch {&#10;                not null =&gt; unknownValue.GetType(),&#10;                null =&gt; throw new ArgumentNullException(nameof(unknownValue), &quot;Cannot get type of null value.&quot;)&#10;            },&#10;            _ =&gt; throw new ArgumentOutOfRangeException()&#10;        };&#10;    }&#10;&#10;    static AnonymousValue Unknown(object value) =&gt; new() { unknownValue = value, ValueType = ValueType.Reference };&#10;&#10;    static AnonymousValue Char(char value) =&gt; new() { charValue = value, ValueType = ValueType.Char };&#10;    static AnonymousValue Bool(bool value) =&gt; new() { boolValue = value, ValueType = ValueType.Bool };&#10;&#10;    static AnonymousValue Byte(byte value) =&gt; new() { byteValue = value, ValueType = ValueType.Byte };&#10;    static AnonymousValue SByte(sbyte value) =&gt; new() { sbyteValue = value, ValueType = ValueType.SByte };&#10;    static AnonymousValue Short(short value) =&gt; new() { shortValue = value, ValueType = ValueType.Short };&#10;    static AnonymousValue UShort(ushort value) =&gt; new() { ushortValue = value, ValueType = ValueType.UShort };&#10;    static AnonymousValue Int(int value) =&gt; new() { intValue = value, ValueType = ValueType.Int };&#10;    static AnonymousValue UInt(uint value) =&gt; new() { uintValue = value, ValueType = ValueType.UInt };&#10;    static AnonymousValue Long(long value) =&gt; new() { longValue = value, ValueType = ValueType.Long };&#10;    static AnonymousValue ULong(ulong value) =&gt; new() { ulongValue = value, ValueType = ValueType.ULong };&#10;&#10;    static AnonymousValue Float(float value) =&gt; new() { floatValue = value, ValueType = ValueType.Float };&#10;    static AnonymousValue Double(double value) =&gt; new() { doubleValue = value, ValueType = ValueType.Double };&#10;    static AnonymousValue Decimal(decimal value) =&gt; new() { decimalValue = value, ValueType = ValueType.Decimal };&#10;&#10;    public bool Equals(AnonymousValue other) {&#10;        if (ValueType != other.ValueType)&#10;            return false;&#10;&#10;        return ValueType switch {&#10;            ValueType.Char =&gt; charValue == other.charValue,&#10;            ValueType.Bool =&gt; boolValue == other.boolValue,&#10;&#10;            ValueType.Byte =&gt; byteValue == other.byteValue,&#10;            ValueType.SByte =&gt; sbyteValue == other.sbyteValue,&#10;            ValueType.Short =&gt; shortValue == other.shortValue,&#10;            ValueType.UShort =&gt; ushortValue == other.ushortValue,&#10;            ValueType.Int =&gt; intValue == other.intValue,&#10;            ValueType.UInt =&gt; uintValue == other.uintValue,&#10;            ValueType.Long =&gt; longValue == other.longValue,&#10;            ValueType.ULong =&gt; ulongValue == other.ulongValue,&#10;&#10;            ValueType.Float =&gt; floatValue.Equals(other.floatValue),&#10;            ValueType.Double =&gt; doubleValue.Equals(other.doubleValue),&#10;            ValueType.Decimal =&gt; decimalValue.Equals(other.decimalValue),&#10;&#10;            _ =&gt; Equals(unknownValue, other.unknownValue)&#10;        };&#10;    }&#10;&#10;    public override bool Equals(object? obj) {&#10;        return obj is AnonymousValue value &amp;&amp; Equals(value);&#10;    }&#10;&#10;    public override int GetHashCode() {&#10;        return ValueType switch {&#10;            ValueType.Char =&gt; HashCode.Combine(ValueType, charValue),&#10;            ValueType.Bool =&gt; HashCode.Combine(ValueType, boolValue),&#10;            ValueType.Byte =&gt; HashCode.Combine(ValueType, byteValue),&#10;            ValueType.SByte =&gt; HashCode.Combine(ValueType, sbyteValue),&#10;            ValueType.Short =&gt; HashCode.Combine(ValueType, shortValue),&#10;            ValueType.UShort =&gt; HashCode.Combine(ValueType, ushortValue),&#10;            ValueType.Int =&gt; HashCode.Combine(ValueType, intValue),&#10;            ValueType.UInt =&gt; HashCode.Combine(ValueType, uintValue),&#10;            ValueType.Long =&gt; HashCode.Combine(ValueType, longValue),&#10;            ValueType.ULong =&gt; HashCode.Combine(ValueType, ulongValue),&#10;            ValueType.Float =&gt; HashCode.Combine(ValueType, floatValue),&#10;            ValueType.Double =&gt; HashCode.Combine(ValueType, doubleValue),&#10;            ValueType.Decimal =&gt; HashCode.Combine(ValueType, decimalValue),&#10;            ValueType.Reference =&gt; HashCode.Combine(ValueType, unknownValue?.GetHashCode() ?? 0),&#10;            _ =&gt; throw new ArgumentOutOfRangeException()&#10;        };&#10;    }&#10;&#10;    public static bool operator ==(AnonymousValue left, AnonymousValue right) {&#10;        return left.Equals(right);&#10;    }&#10;&#10;    public static bool operator !=(AnonymousValue left, AnonymousValue right) {&#10;        return !(left == right);&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Runtime.CompilerServices;&#10;using System.Runtime.InteropServices;&#10;&#10;namespace Closures;&#10;&#10;internal enum ValueType {&#10;    Reference,&#10;&#10;    Char,&#10;    Bool,&#10;&#10;    Byte,&#10;    SByte,&#10;    Short,&#10;    UShort,&#10;    Int,&#10;    UInt,&#10;    Long,&#10;    ULong,&#10;&#10;    Float,&#10;    Double,&#10;    Decimal,&#10;}&#10;&#10;internal static class ValueTypeExtensions {&#10;    public static bool IsOrReference&lt;T&gt;(this ValueType valueType) {&#10;        return valueType switch {&#10;            ValueType.Char =&gt; typeof(T) == typeof(char),&#10;            ValueType.Bool =&gt; typeof(T) == typeof(bool),&#10;&#10;            ValueType.Byte =&gt; typeof(T) == typeof(byte),&#10;            ValueType.SByte =&gt; typeof(T) == typeof(sbyte),&#10;            ValueType.Short =&gt; typeof(T) == typeof(short),&#10;            ValueType.UShort =&gt; typeof(T) == typeof(ushort),&#10;            ValueType.Int =&gt; typeof(T) == typeof(int),&#10;            ValueType.UInt =&gt; typeof(T) == typeof(uint),&#10;            ValueType.Long =&gt; typeof(T) == typeof(long),&#10;            ValueType.ULong =&gt; typeof(T) == typeof(ulong),&#10;&#10;            ValueType.Float =&gt; typeof(T) == typeof(float),&#10;            ValueType.Double =&gt; typeof(T) == typeof(double),&#10;            ValueType.Decimal =&gt; typeof(T) == typeof(decimal),&#10;&#10;            ValueType.Reference =&gt; true,&#10;            _ =&gt; false&#10;        };&#10;    }&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// A struct that can hold any value or reference type.&#10;/// &lt;/summary&gt;&#10;[StructLayout(LayoutKind.Explicit)]&#10;public struct AnonymousValue : IEquatable&lt;AnonymousValue&gt; {&#10;    [FieldOffset(0)] ValueType ValueType;&#10;&#10;    [FieldOffset(8)] object? unknownValue;&#10;&#10;    [FieldOffset(16)] char charValue;&#10;    [FieldOffset(16)] bool boolValue;&#10;&#10;    [FieldOffset(16)] byte byteValue;&#10;    [FieldOffset(16)] sbyte sbyteValue;&#10;    [FieldOffset(16)] short shortValue;&#10;    [FieldOffset(16)] ushort ushortValue;&#10;    [FieldOffset(16)] int intValue;&#10;    [FieldOffset(16)] uint uintValue;&#10;    [FieldOffset(16)] long longValue;&#10;    [FieldOffset(16)] ulong ulongValue;&#10;&#10;    [FieldOffset(16)] float floatValue;&#10;    [FieldOffset(16)] double doubleValue;&#10;    [FieldOffset(16)] decimal decimalValue;&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates an AnonymousValue from a value of any type.&#10;    /// The type must be a value type or a reference type that is not null.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to create from&lt;/param&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;Type of the value&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;&lt;/returns&gt;&#10;    public static AnonymousValue From&lt;T&gt;(T value) where T : notnull {&#10;        return typeof(T) switch {&#10;            { } t when t == typeof(char) =&gt; Char(Unsafe.As&lt;T, char&gt;(ref value)),&#10;            { } t when t == typeof(bool) =&gt; Bool(Unsafe.As&lt;T, bool&gt;(ref value)),&#10;&#10;            { } t when t == typeof(byte) =&gt; Byte(Unsafe.As&lt;T, byte&gt;(ref value)),&#10;            { } t when t == typeof(sbyte) =&gt; SByte(Unsafe.As&lt;T, sbyte&gt;(ref value)),&#10;            { } t when t == typeof(short) =&gt; Short(Unsafe.As&lt;T, short&gt;(ref value)),&#10;            { } t when t == typeof(ushort) =&gt; UShort(Unsafe.As&lt;T, ushort&gt;(ref value)),&#10;            { } t when t == typeof(int) =&gt; Int(Unsafe.As&lt;T, int&gt;(ref value)),&#10;            { } t when t == typeof(uint) =&gt; UInt(Unsafe.As&lt;T, uint&gt;(ref value)),&#10;            { } t when t == typeof(long) =&gt; Long(Unsafe.As&lt;T, long&gt;(ref value)),&#10;            { } t when t == typeof(ulong) =&gt; ULong(Unsafe.As&lt;T, ulong&gt;(ref value)),&#10;&#10;            { } t when t == typeof(float) =&gt; Float(Unsafe.As&lt;T, float&gt;(ref value)),&#10;            { } t when t == typeof(double) =&gt; Double(Unsafe.As&lt;T, double&gt;(ref value)),&#10;            { } t when t == typeof(decimal) =&gt; Decimal(Unsafe.As&lt;T, decimal&gt;(ref value)),&#10;&#10;            _ =&gt; Unknown(value)&#10;        };&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Checks if the current AnonymousValue is of a specific type.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type to check against&lt;/typeparam&gt;&#10;    public bool Is&lt;T&gt;() =&gt; typeof(T) == GetUnderlyingType();&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Returns the value as the specified type &lt;typeparamref name=&quot;T&quot;/&gt; if possible.&#10;    /// Throws &lt;see cref=&quot;InvalidCastException&quot;/&gt; if the type does not match.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type to cast to&lt;/typeparam&gt;&#10;    /// &lt;returns&gt;The value as type &lt;typeparamref name=&quot;T&quot;/&gt;&lt;/returns&gt;&#10;    public T As&lt;T&gt;() {&#10;        if (ValueType.IsOrReference&lt;T&gt;()) {&#10;            return ValueType switch {&#10;                ValueType.Char =&gt; Unsafe.As&lt;char, T&gt;(ref charValue),&#10;                ValueType.Bool =&gt; Unsafe.As&lt;bool, T&gt;(ref boolValue),&#10;&#10;                ValueType.Byte =&gt; Unsafe.As&lt;byte, T&gt;(ref byteValue),&#10;                ValueType.SByte =&gt; Unsafe.As&lt;sbyte, T&gt;(ref sbyteValue),&#10;                ValueType.Short =&gt; Unsafe.As&lt;short, T&gt;(ref shortValue),&#10;                ValueType.UShort =&gt; Unsafe.As&lt;ushort, T&gt;(ref ushortValue),&#10;                ValueType.Int =&gt; Unsafe.As&lt;int, T&gt;(ref intValue),&#10;                ValueType.UInt =&gt; Unsafe.As&lt;uint, T&gt;(ref uintValue),&#10;                ValueType.Long =&gt; Unsafe.As&lt;long, T&gt;(ref longValue),&#10;&#10;                ValueType.ULong =&gt; Unsafe.As&lt;ulong, T&gt;(ref ulongValue),&#10;&#10;                ValueType.Float =&gt; Unsafe.As&lt;float, T&gt;(ref floatValue),&#10;                ValueType.Double =&gt; Unsafe.As&lt;double, T&gt;(ref doubleValue),&#10;                ValueType.Decimal =&gt; Unsafe.As&lt;decimal, T&gt;(ref decimalValue),&#10;&#10;                ValueType.Reference =&gt; unknownValue switch {&#10;                    T t =&gt; t,&#10;                    null =&gt; throw new NullReferenceException(nameof(unknownValue)),&#10;                    _ =&gt; InvalidCast()&#10;                },&#10;                _ =&gt; InvalidCast()&#10;            };&#10;        }&#10;&#10;        return InvalidCast();&#10;&#10;        T InvalidCast() =&gt; throw new InvalidCastException($&quot;Cannot cast AnonymousValue to {typeof(T).Name}.&quot;);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Sets the value of this &lt;see cref=&quot;AnonymousValue&quot;/&gt; to the specified value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value to set.&lt;/param&gt;&#10;    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the value.&lt;/typeparam&gt;&#10;    public void SetValue&lt;T&gt;(T value) {&#10;        switch (value) {&#10;            case char c:&#10;                charValue = c;&#10;                ValueType = ValueType.Char;&#10;                return;&#10;            case bool b:&#10;                boolValue = b;&#10;                ValueType = ValueType.Bool;&#10;                return;&#10;&#10;            case byte b:&#10;                byteValue = b;&#10;                ValueType = ValueType.Byte;&#10;                return;&#10;            case sbyte sb:&#10;                sbyteValue = sb;&#10;                ValueType = ValueType.SByte;&#10;                return;&#10;            case short s:&#10;                shortValue = s;&#10;                ValueType = ValueType.Short;&#10;                return;&#10;            case ushort us:&#10;                ushortValue = us;&#10;                ValueType = ValueType.UShort;&#10;                return;&#10;            case int i:&#10;                intValue = i;&#10;                ValueType = ValueType.Int;&#10;                return;&#10;            case uint ui:&#10;                uintValue = ui;&#10;                ValueType = ValueType.UInt;&#10;                return;&#10;            case long l:&#10;                longValue = l;&#10;                ValueType = ValueType.Long;&#10;                return;&#10;            case ulong ul:&#10;                ulongValue = ul;&#10;                ValueType = ValueType.ULong;&#10;                return;&#10;&#10;            case float f:&#10;                floatValue = f;&#10;                ValueType = ValueType.Float;&#10;                return;&#10;            case double d:&#10;                doubleValue = d;&#10;                ValueType = ValueType.Double;&#10;                return;&#10;            case decimal dec:&#10;                decimalValue = dec;&#10;                ValueType = ValueType.Decimal;&#10;                return;&#10;&#10;            default:&#10;                unknownValue = value ??&#10;                               throw new ArgumentNullException(nameof(value),&#10;                                   &quot;Cannot set null value to AnonymousValue.&quot;);&#10;                ValueType = ValueType.Reference;&#10;                return;&#10;        }&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Gets the underlying type of the value stored in this &lt;see cref=&quot;AnonymousValue&quot;/&gt;.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;returns&gt;The &lt;see cref=&quot;Type&quot;/&gt; of the stored value, or null if unknown.&lt;/returns&gt;&#10;    public Type GetUnderlyingType() {&#10;        return ValueType switch {&#10;            ValueType.Char =&gt; typeof(char),&#10;            ValueType.Bool =&gt; typeof(bool),&#10;&#10;            ValueType.Byte =&gt; typeof(byte),&#10;            ValueType.SByte =&gt; typeof(sbyte),&#10;            ValueType.Short =&gt; typeof(short),&#10;            ValueType.UShort =&gt; typeof(ushort),&#10;            ValueType.Int =&gt; typeof(int),&#10;            ValueType.UInt =&gt; typeof(uint),&#10;            ValueType.Long =&gt; typeof(long),&#10;            ValueType.ULong =&gt; typeof(ulong),&#10;&#10;            ValueType.Float =&gt; typeof(float),&#10;            ValueType.Double =&gt; typeof(double),&#10;            ValueType.Decimal =&gt; typeof(decimal),&#10;&#10;            ValueType.Reference =&gt; unknownValue switch {&#10;                not null =&gt; unknownValue.GetType(),&#10;                null =&gt; throw new ArgumentNullException(nameof(unknownValue), &quot;Cannot get type of null value.&quot;)&#10;            },&#10;            _ =&gt; throw new ArgumentOutOfRangeException()&#10;        };&#10;    }&#10;&#10;    static AnonymousValue Unknown(object value) =&gt; new() { unknownValue = value, ValueType = ValueType.Reference };&#10;&#10;    static AnonymousValue Char(char value) =&gt; new() { charValue = value, ValueType = ValueType.Char };&#10;    static AnonymousValue Bool(bool value) =&gt; new() { boolValue = value, ValueType = ValueType.Bool };&#10;&#10;    static AnonymousValue Byte(byte value) =&gt; new() { byteValue = value, ValueType = ValueType.Byte };&#10;    static AnonymousValue SByte(sbyte value) =&gt; new() { sbyteValue = value, ValueType = ValueType.SByte };&#10;    static AnonymousValue Short(short value) =&gt; new() { shortValue = value, ValueType = ValueType.Short };&#10;    static AnonymousValue UShort(ushort value) =&gt; new() { ushortValue = value, ValueType = ValueType.UShort };&#10;    static AnonymousValue Int(int value) =&gt; new() { intValue = value, ValueType = ValueType.Int };&#10;    static AnonymousValue UInt(uint value) =&gt; new() { uintValue = value, ValueType = ValueType.UInt };&#10;    static AnonymousValue Long(long value) =&gt; new() { longValue = value, ValueType = ValueType.Long };&#10;    static AnonymousValue ULong(ulong value) =&gt; new() { ulongValue = value, ValueType = ValueType.ULong };&#10;&#10;    static AnonymousValue Float(float value) =&gt; new() { floatValue = value, ValueType = ValueType.Float };&#10;    static AnonymousValue Double(double value) =&gt; new() { doubleValue = value, ValueType = ValueType.Double };&#10;    static AnonymousValue Decimal(decimal value) =&gt; new() { decimalValue = value, ValueType = ValueType.Decimal };&#10;&#10;    public bool Equals(AnonymousValue other) {&#10;        if (ValueType != other.ValueType)&#10;            return false;&#10;&#10;        return ValueType switch {&#10;            ValueType.Char =&gt; charValue == other.charValue,&#10;            ValueType.Bool =&gt; boolValue == other.boolValue,&#10;&#10;            ValueType.Byte =&gt; byteValue == other.byteValue,&#10;            ValueType.SByte =&gt; sbyteValue == other.sbyteValue,&#10;            ValueType.Short =&gt; shortValue == other.shortValue,&#10;            ValueType.UShort =&gt; ushortValue == other.ushortValue,&#10;            ValueType.Int =&gt; intValue == other.intValue,&#10;            ValueType.UInt =&gt; uintValue == other.uintValue,&#10;            ValueType.Long =&gt; longValue == other.longValue,&#10;            ValueType.ULong =&gt; ulongValue == other.ulongValue,&#10;&#10;            ValueType.Float =&gt; floatValue.Equals(other.floatValue),&#10;            ValueType.Double =&gt; doubleValue.Equals(other.doubleValue),&#10;            ValueType.Decimal =&gt; decimalValue.Equals(other.decimalValue),&#10;&#10;            _ =&gt; Equals(unknownValue, other.unknownValue)&#10;        };&#10;    }&#10;&#10;    public override bool Equals(object? obj) {&#10;        return obj is AnonymousValue value &amp;&amp; Equals(value);&#10;    }&#10;&#10;    public override int GetHashCode() {&#10;        return ValueType switch {&#10;            ValueType.Char =&gt; HashCode.Combine(ValueType, charValue),&#10;            ValueType.Bool =&gt; HashCode.Combine(ValueType, boolValue),&#10;            ValueType.Byte =&gt; HashCode.Combine(ValueType, byteValue),&#10;            ValueType.SByte =&gt; HashCode.Combine(ValueType, sbyteValue),&#10;            ValueType.Short =&gt; HashCode.Combine(ValueType, shortValue),&#10;            ValueType.UShort =&gt; HashCode.Combine(ValueType, ushortValue),&#10;            ValueType.Int =&gt; HashCode.Combine(ValueType, intValue),&#10;            ValueType.UInt =&gt; HashCode.Combine(ValueType, uintValue),&#10;            ValueType.Long =&gt; HashCode.Combine(ValueType, longValue),&#10;            ValueType.ULong =&gt; HashCode.Combine(ValueType, ulongValue),&#10;            ValueType.Float =&gt; HashCode.Combine(ValueType, floatValue),&#10;            ValueType.Double =&gt; HashCode.Combine(ValueType, doubleValue),&#10;            ValueType.Decimal =&gt; HashCode.Combine(ValueType, decimalValue),&#10;            ValueType.Reference =&gt; HashCode.Combine(ValueType, unknownValue?.GetHashCode() ?? 0),&#10;            _ =&gt; throw new ArgumentOutOfRangeException()&#10;        };&#10;    }&#10;&#10;    public static bool operator ==(AnonymousValue left, AnonymousValue right) {&#10;        return left.Equals(right);&#10;    }&#10;&#10;    public static bool operator !=(AnonymousValue left, AnonymousValue right) {&#10;        return !(left == right);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Anonymous/Result.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Anonymous/Result.cs" />
              <option name="originalContent" value="// ReSharper disable ConvertToPrimaryConstructor&#10;&#10;namespace Closures;&#10;&#10;public readonly record struct Result {&#10;    public readonly bool IsSuccess;&#10;    public readonly Exception? Exception;&#10;    &#10;    public static implicit operator bool(Result result) =&gt; result.IsSuccess;&#10;    &#10;    Result(bool isSuccess, Exception? ex = null) {&#10;        IsSuccess = isSuccess;&#10;        Exception = ex;&#10;    }&#10;&#10;    public static Result Success() =&gt; new(true);&#10;    public static Result Failure(Exception ex) =&gt; new(false, ex);&#10;}&#10;&#10;public readonly record struct Result&lt;T&gt; {&#10;    public readonly bool IsSuccess;&#10;    public readonly T? Value;&#10;    public readonly Exception? Exception;&#10;    &#10;    public static implicit operator bool(Result&lt;T&gt; result) =&gt; result.IsSuccess;&#10;    &#10;    Result(bool isSuccess, T? value = default, Exception? ex = null) {&#10;        IsSuccess = isSuccess;&#10;        Value = value;&#10;        Exception = ex;&#10;    }&#10;&#10;    public static Result&lt;T&gt; Success(T value) =&gt; new(true, value);&#10;    public static Result&lt;T&gt; Failure(Exception ex) =&gt; new(false, default, ex);&#10;}" />
              <option name="updatedContent" value="// ReSharper disable ConvertToPrimaryConstructor&#10;&#10;namespace Closures;&#10;&#10;/// &lt;summary&gt;&#10;/// Represents the result of an operation, indicating success or failure and an optional exception.&#10;/// &lt;/summary&gt;&#10;public readonly record struct Result {&#10;    /// &lt;summary&gt;&#10;    /// Indicates whether the operation was successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly bool IsSuccess;&#10;    /// &lt;summary&gt;&#10;    /// The exception associated with a failed operation, or &lt;c&gt;null&lt;/c&gt; if successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly Exception? Exception;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Implicitly converts the result to a boolean indicating success.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;result&quot;&gt;The result to convert.&lt;/param&gt;&#10;    public static implicit operator bool(Result result) =&gt; result.IsSuccess;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;Result&quot;/&gt; struct.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;isSuccess&quot;&gt;Whether the operation was successful.&lt;/param&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception if the operation failed, or &lt;c&gt;null&lt;/c&gt; if successful.&lt;/param&gt;&#10;    Result(bool isSuccess, Exception? ex = null) {&#10;        IsSuccess = isSuccess;&#10;        Exception = ex;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a successful result.&#10;    /// &lt;/summary&gt;&#10;    public static Result Success() =&gt; new(true);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a failed result with the specified exception.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception representing the failure.&lt;/param&gt;&#10;    public static Result Failure(Exception ex) =&gt; new(false, ex);&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Represents the result of an operation that returns a value, indicating success or failure, the value, and an optional exception.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;T&quot;&gt;The type of the value returned by the operation.&lt;/typeparam&gt;&#10;public readonly record struct Result&lt;T&gt; {&#10;    /// &lt;summary&gt;&#10;    /// Indicates whether the operation was successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly bool IsSuccess;&#10;    /// &lt;summary&gt;&#10;    /// The value returned by the operation if successful, or &lt;c&gt;default&lt;/c&gt; if failed.&#10;    /// &lt;/summary&gt;&#10;    public readonly T? Value;&#10;    /// &lt;summary&gt;&#10;    /// The exception associated with a failed operation, or &lt;c&gt;null&lt;/c&gt; if successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly Exception? Exception;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Implicitly converts the result to a boolean indicating success.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;result&quot;&gt;The result to convert.&lt;/param&gt;&#10;    public static implicit operator bool(Result&lt;T&gt; result) =&gt; result.IsSuccess;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;Result{T}&quot;/&gt; struct.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;isSuccess&quot;&gt;Whether the operation was successful.&lt;/param&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value returned by the operation, or &lt;c&gt;default&lt;/c&gt; if failed.&lt;/param&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception if the operation failed, or &lt;c&gt;null&lt;/c&gt; if successful.&lt;/param&gt;&#10;    Result(bool isSuccess, T? value = default, Exception? ex = null) {&#10;        IsSuccess = isSuccess;&#10;        Value = value;&#10;        Exception = ex;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a successful result with the specified value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value returned by the operation.&lt;/param&gt;&#10;    public static Result&lt;T&gt; Success(T value) =&gt; new(true, value);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a failed result with the specified exception.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception representing the failure.&lt;/param&gt;&#10;    public static Result&lt;T&gt; Failure(Exception ex) =&gt; new(false, default, ex);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Closure.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Closure.cs" />
              <option name="originalContent" value="using System.Collections.Concurrent;&#10;&#10;namespace Closures {&#10;&#10;    /// &lt;summary&gt;&#10;    /// Marker interface for closure types.&#10;    /// &lt;/summary&gt;&#10;    public interface IClosure {&#10;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Represents a closure that encapsulates a context and a delegate.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TContext&quot;&gt; Type of the context to capture &lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt; Type of the delegate to invoke &lt;/typeparam&gt;&#10;    public interface IClosure&lt;TContext, TDelegate&gt; : IClosure where TDelegate : Delegate {&#10;        TContext Context { get; init; }&#10;        TDelegate Delegate { get; init; }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Marker interface for closures that can mutate the context.&#10;    /// &lt;/summary&gt;&#10;    public interface IMutatingClosure {&#10;        &#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Interface for closures that provide a reference to the context.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TContext&quot;&gt;&lt;/typeparam&gt;&#10;    public interface IRefClosure&lt;TContext&gt; {&#10;        ref TContext RefContext { get; }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Factory class for creating closure structs that encapsulate context and delegate logic.&#10;    /// &lt;/summary&gt;&#10;    public static class ClosureFactory {&#10;        /// &lt;summary&gt;&#10;        /// Creates a new closure struct of type &lt;typeparamref name=&quot;TClosure&quot;/&gt; that encapsulates the specified context and delegate.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;typeparam name=&quot;TContext&quot;&gt;The type of the context to capture.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The type of the delegate to invoke.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TClosure&quot;&gt;The closure struct type implementing &lt;see cref=&quot;IClosure{TContext, TDelegate}&quot;/&gt;.&lt;/typeparam&gt;&#10;        /// &lt;param name=&quot;context&quot;&gt;The context value to capture in the closure.&lt;/param&gt;&#10;        /// &lt;param name=&quot;delegate&quot;&gt;The delegate to associate with the closure.&lt;/param&gt;&#10;        /// &lt;returns&gt;A new &lt;typeparamref name=&quot;TClosure&quot;/&gt; instance with its &lt;c&gt;Context&lt;/c&gt; and &lt;c&gt;Delegate&lt;/c&gt; properties initialized.&lt;/returns&gt;&#10;        public static TClosure Create&lt;TContext, TDelegate, TClosure&gt;(TContext context, TDelegate @delegate)&#10;            where TClosure : struct, IClosure&lt;TContext, TDelegate&gt; where TDelegate : Delegate&#10;            =&gt; new TClosure() {&#10;                Delegate = @delegate,&#10;                Context = context&#10;            };&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Provides factory methods for creating closure structs that encapsulate context and delegate logic.&#10;    /// &lt;/summary&gt;&#10;    public partial struct Closure {&#10;        /// &lt;summary&gt; Creates an &lt;see cref=&quot;ClosureAction{TContext}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static ClosureAction&lt;TContext&gt; Action&lt;TContext&gt;(TContext context, Action&lt;TContext&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, Action&lt;TContext&gt;, ClosureAction&lt;TContext&gt;&gt;(context, action);&#10;    &#10;        /// &lt;summary&gt; Creates an &lt;see cref=&quot;ClosureAction{TContext, TArg}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static ClosureAction&lt;TContext, TArg&gt; Action&lt;TContext, TArg&gt;(TContext context, Action&lt;TContext, TArg&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, Action&lt;TContext, TArg&gt;, ClosureAction&lt;TContext, TArg&gt;&gt;(context, action);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;ClosureRefAction{TContext, TArg}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static ClosureRefAction&lt;TContext, TArg&gt; RefAction&lt;TContext, TArg&gt;(TContext context, RefActionWithNormalContext&lt;TContext, TArg&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefActionWithNormalContext&lt;TContext, TArg&gt;, ClosureRefAction&lt;TContext, TArg&gt;&gt;(context, action);&#10;        &#10;        &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;ClosureFunc{TContext, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static ClosureFunc&lt;TContext, TResult&gt; Func&lt;TContext, TResult&gt;(TContext context, Func&lt;TContext, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, Func&lt;TContext, TResult&gt;, ClosureFunc&lt;TContext, TResult&gt;&gt;(context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;ClosureFunc{TContext, TArg, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static ClosureFunc&lt;TContext, TArg, TResult&gt; Func&lt;TContext, TArg, TResult&gt;(TContext context, Func&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, Func&lt;TContext, TArg, TResult&gt;, ClosureFunc&lt;TContext, TArg, TResult&gt;&gt;(context, func);&#10;    &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;ClosureRefFunc{TContext, TArg, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static ClosureRefFunc&lt;TContext, TArg, TResult&gt; RefFunc&lt;TContext, TArg, TResult&gt;(TContext context, RefFuncWithNormalContext&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefFuncWithNormalContext&lt;TContext, TArg, TResult&gt;, ClosureRefFunc&lt;TContext, TArg, TResult&gt;&gt;(context, func);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Provides factory methods for creating mutating closure structs that encapsulate context and delegate logic.&#10;    /// &lt;/summary&gt;&#10;    public struct MutatingClosure {&#10;        /// &lt;summary&gt; Creates an &lt;see cref=&quot;MutatingClosureAction{TContext}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static MutatingClosureAction&lt;TContext&gt; Action&lt;TContext&gt;(TContext context, RefAction&lt;TContext&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefAction&lt;TContext&gt;, MutatingClosureAction&lt;TContext&gt;&gt;(context, action);&#10;    &#10;        /// &lt;summary&gt; Creates an &lt;see cref=&quot;MutatingClosureAction{TContext, TArg}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static MutatingClosureAction&lt;TContext, TArg&gt; Action&lt;TContext, TArg&gt;(TContext context, ActionWithRefContext&lt;TContext, TArg&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, ActionWithRefContext&lt;TContext, TArg&gt;, MutatingClosureAction&lt;TContext, TArg&gt;&gt;(context, action);&#10;    &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;MutatingClosureRefAction{TContext, TArg}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static MutatingClosureRefAction&lt;TContext, TArg&gt; RefAction&lt;TContext, TArg&gt;(TContext context, RefAction&lt;TContext, TArg&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefAction&lt;TContext, TArg&gt;, MutatingClosureRefAction&lt;TContext, TArg&gt;&gt;(context, action);&#10;        &#10;        &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;MutatingClosureFunc{TContext, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static MutatingClosureFunc&lt;TContext, TResult&gt; Func&lt;TContext, TResult&gt;(TContext context, RefFunc&lt;TContext, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefFunc&lt;TContext, TResult&gt;, MutatingClosureFunc&lt;TContext, TResult&gt;&gt;(context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;MutatingClosureFunc{TContext, TArg, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static MutatingClosureFunc&lt;TContext, TArg, TResult&gt; Func&lt;TContext, TArg, TResult&gt;(TContext context, FuncWithRefContext&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, FuncWithRefContext&lt;TContext, TArg, TResult&gt;, MutatingClosureFunc&lt;TContext, TArg, TResult&gt;&gt;(context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;MutatingClosureRefFunc{TContext, TArg, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static MutatingClosureRefFunc&lt;TContext, TArg, TResult&gt; RefFunc&lt;TContext, TArg, TResult&gt;(TContext context, RefFunc&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefFunc&lt;TContext, TArg, TResult&gt;, MutatingClosureRefFunc&lt;TContext, TArg, TResult&gt;&gt;(context, func);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Provides factory methods for creating ref closure structs that encapsulate a context by reference and delegate logic,&#10;    /// &lt;/summary&gt;&#10;    public struct RefClosure {&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureAction{TContext}&quot;/&gt; with the specified ref context and action. &lt;/summary&gt;&#10;        public static RefClosureAction&lt;TContext&gt; Action&lt;TContext&gt;(ref TContext context, RefAction&lt;TContext&gt; action) =&gt;&#10;            new RefClosureAction&lt;TContext&gt;(ref context, action);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureAction{TContext, TArg}&quot;/&gt; with the specified ref context and action. &lt;/summary&gt;&#10;        public static RefClosureAction&lt;TContext, TArg&gt; Action&lt;TContext, TArg&gt;(ref TContext context, ActionWithRefContext&lt;TContext, TArg&gt; action) =&gt;&#10;            new RefClosureAction&lt;TContext, TArg&gt;(ref context, action);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureRefAction{TContext, TArg}&quot;/&gt; with the specified ref context and action. &lt;/summary&gt;&#10;        public static RefClosureRefAction&lt;TContext, TArg&gt; RefAction&lt;TContext, TArg&gt;(ref TContext context, RefAction&lt;TContext, TArg&gt; action) =&gt;&#10;            new RefClosureRefAction&lt;TContext, TArg&gt;(ref context, action);&#10;        &#10;        &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureFunc{TContext, TResult}&quot;/&gt; with the specified ref context and function. &lt;/summary&gt;&#10;        public static RefClosureFunc&lt;TContext, TResult&gt; Func&lt;TContext, TResult&gt;(ref TContext context, RefFunc&lt;TContext, TResult&gt; func) =&gt;&#10;            new RefClosureFunc&lt;TContext, TResult&gt;(ref context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureFunc{TContext, TArg, TResult}&quot;/&gt; with the specified ref context and function. &lt;/summary&gt;&#10;        public static RefClosureFunc&lt;TContext, TArg, TResult&gt; Func&lt;TContext, TArg, TResult&gt;(ref TContext context, FuncWithRefContext&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            new RefClosureFunc&lt;TContext, TArg, TResult&gt;(ref context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureRefFunc{TContext, TArg, TResult}&quot;/&gt; with the specified ref context and ref argument function. &lt;/summary&gt;&#10;        public static RefClosureRefFunc&lt;TContext, TArg, TResult&gt; RefFunc&lt;TContext, TArg, TResult&gt;(ref TContext context, RefFunc&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            new RefClosureRefFunc&lt;TContext, TArg, TResult&gt;(ref context, func);&#10;    }&#10;    &#10;    public static class ClosureManager {&#10;        public static event Action? OnCacheClear;&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Clears all caches in the system.&#10;        /// &lt;/summary&gt;&#10;        public static void ClearCache() {&#10;            OnCacheClear?.Invoke();&#10;        }&#10;    }&#10;    &#10;    public static class ClosureExtensions {&#10;        public static Action AsAction&lt;TContext&gt;(this ClosureAction&lt;TContext&gt; closure) =&gt; ClosureToAction&lt;TContext&gt;.AsAction(closure);&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts a &lt;see cref=&quot;ClosureAction{TContext, TArg}&quot;/&gt; to an &lt;see cref=&quot;Action{TArg}&quot;/&gt; delegate.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;typeparam name=&quot;TContext&quot;&gt;The type of the captured context.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument.&lt;/typeparam&gt;&#10;        /// &lt;param name=&quot;closure&quot;&gt;The closure to convert.&lt;/param&gt;&#10;        /// &lt;returns&gt;An &lt;see cref=&quot;Action{TArg}&quot;/&gt; that invokes the closure with its captured context and the provided argument.&lt;/returns&gt;&#10;        public static Action&lt;TArg&gt; AsAction&lt;TContext, TArg&gt;(this ClosureAction&lt;TContext, TArg&gt; closure) =&gt; ClosureToAction&lt;TContext, TArg&gt;.AsAction(closure);&#10;        public static Func&lt;TResult&gt; AsFunc&lt;TContext, TResult&gt;(this ClosureFunc&lt;TContext, TResult&gt; closure) =&gt; ClosureToFunc&lt;TContext, TResult&gt;.AsFunc(closure);&#10;        public static Func&lt;TArg, TResult&gt; AsFunc&lt;TContext, TArg, TResult&gt;(this ClosureFunc&lt;TContext, TArg, TResult&gt; closure) =&gt; ClosureToFunc&lt;TContext, TArg, TResult&gt;.AsFunc(closure);&#10;    }&#10;    &#10;    // ReSharper disable ConvertClosureToMethodGroup&#10;    internal static class ClosureToAction&lt;TContext&gt; {&#10;        static readonly ConcurrentDictionary&lt;ClosureAction&lt;TContext&gt;, Action&gt; s_closureToActionMap = new ();&#10;        static ClosureToAction() =&gt; ClosureManager.OnCacheClear += () =&gt; s_closureToActionMap.Clear();&#10;        public static Action AsAction(ClosureAction&lt;TContext&gt; closure) =&gt; s_closureToActionMap.GetOrAdd(closure, c =&gt; () =&gt; c.Invoke());&#10;    }&#10;    &#10;    internal static class ClosureToAction&lt;TContext, TArg&gt; {&#10;        static readonly ConcurrentDictionary&lt;ClosureAction&lt;TContext, TArg&gt;, Action&lt;TArg&gt;&gt; s_closureToActionMap = new ();&#10;        static ClosureToAction() =&gt; ClosureManager.OnCacheClear += () =&gt; s_closureToActionMap.Clear();&#10;        public static Action&lt;TArg&gt; AsAction(ClosureAction&lt;TContext, TArg&gt; closure) =&gt; s_closureToActionMap.GetOrAdd(closure, c =&gt; arg =&gt; c.Invoke(arg));&#10;    }&#10;    &#10;    internal static class ClosureToFunc&lt;TContext, TResult&gt; {&#10;        static readonly ConcurrentDictionary&lt;ClosureFunc&lt;TContext, TResult&gt;, Func&lt;TResult&gt;&gt; s_closureToFuncMap = new ();&#10;        static ClosureToFunc() =&gt; ClosureManager.OnCacheClear += () =&gt; s_closureToFuncMap.Clear();&#10;        public static Func&lt;TResult&gt; AsFunc(ClosureFunc&lt;TContext, TResult&gt; closure) =&gt; s_closureToFuncMap.GetOrAdd(closure, c =&gt; () =&gt; c.Invoke());&#10;    }&#10;    &#10;    internal static class ClosureToFunc&lt;TContext, TArg, TResult&gt; {&#10;        static readonly ConcurrentDictionary&lt;ClosureFunc&lt;TContext, TArg, TResult&gt;, Func&lt;TArg, TResult&gt;&gt; s_closureToFuncMap = new ();&#10;        static ClosureToFunc() =&gt; ClosureManager.OnCacheClear += () =&gt; s_closureToFuncMap.Clear();&#10;        public static Func&lt;TArg, TResult&gt; AsFunc(ClosureFunc&lt;TContext, TArg, TResult&gt; closure) =&gt; s_closureToFuncMap.GetOrAdd(closure, c =&gt; arg =&gt; c.Invoke(arg));&#10;    }&#10;    // ReSharper restore ConvertClosureToMethodGroup&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections.Concurrent;&#10;&#10;namespace Closures {&#10;&#10;    /// &lt;summary&gt;&#10;    /// Marker interface for closure types.&#10;    /// &lt;/summary&gt;&#10;    public interface IClosure {&#10;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Represents a closure that encapsulates a context and a delegate.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TContext&quot;&gt; Type of the context to capture &lt;/typeparam&gt;&#10;    /// &lt;typeparam name=&quot;TDelegate&quot;&gt; Type of the delegate to invoke &lt;/typeparam&gt;&#10;    public interface IClosure&lt;TContext, TDelegate&gt; : IClosure where TDelegate : Delegate {&#10;        TContext Context { get; init; }&#10;        TDelegate Delegate { get; init; }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Marker interface for closures that can mutate the context.&#10;    /// &lt;/summary&gt;&#10;    public interface IMutatingClosure {&#10;        &#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Interface for closures that provide a reference to the context.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;typeparam name=&quot;TContext&quot;&gt;&lt;/typeparam&gt;&#10;    public interface IRefClosure&lt;TContext&gt; {&#10;        ref TContext RefContext { get; }&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Factory class for creating closure structs that encapsulate context and delegate logic.&#10;    /// &lt;/summary&gt;&#10;    public static class ClosureFactory {&#10;        /// &lt;summary&gt;&#10;        /// Creates a new closure struct of type &lt;typeparamref name=&quot;TClosure&quot;/&gt; that encapsulates the specified context and delegate.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;typeparam name=&quot;TContext&quot;&gt;The type of the context to capture.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TDelegate&quot;&gt;The type of the delegate to invoke.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TClosure&quot;&gt;The closure struct type implementing &lt;see cref=&quot;IClosure{TContext, TDelegate}&quot;/&gt;.&lt;/typeparam&gt;&#10;        /// &lt;param name=&quot;context&quot;&gt;The context value to capture in the closure.&lt;/param&gt;&#10;        /// &lt;param name=&quot;delegate&quot;&gt;The delegate to associate with the closure.&lt;/param&gt;&#10;        /// &lt;returns&gt;A new &lt;typeparamref name=&quot;TClosure&quot;/&gt; instance with its &lt;c&gt;Context&lt;/c&gt; and &lt;c&gt;Delegate&lt;/c&gt; properties initialized.&lt;/returns&gt;&#10;        public static TClosure Create&lt;TContext, TDelegate, TClosure&gt;(TContext context, TDelegate @delegate)&#10;            where TClosure : struct, IClosure&lt;TContext, TDelegate&gt; where TDelegate : Delegate&#10;            =&gt; new TClosure() {&#10;                Delegate = @delegate,&#10;                Context = context&#10;            };&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Provides factory methods for creating closure structs that encapsulate context and delegate logic.&#10;    /// &lt;/summary&gt;&#10;    public partial struct Closure {&#10;        /// &lt;summary&gt; Creates an &lt;see cref=&quot;ClosureAction{TContext}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static ClosureAction&lt;TContext&gt; Action&lt;TContext&gt;(TContext context, Action&lt;TContext&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, Action&lt;TContext&gt;, ClosureAction&lt;TContext&gt;&gt;(context, action);&#10;    &#10;        /// &lt;summary&gt; Creates an &lt;see cref=&quot;ClosureAction{TContext, TArg}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static ClosureAction&lt;TContext, TArg&gt; Action&lt;TContext, TArg&gt;(TContext context, Action&lt;TContext, TArg&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, Action&lt;TContext, TArg&gt;, ClosureAction&lt;TContext, TArg&gt;&gt;(context, action);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;ClosureRefAction{TContext, TArg}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static ClosureRefAction&lt;TContext, TArg&gt; RefAction&lt;TContext, TArg&gt;(TContext context, RefActionWithNormalContext&lt;TContext, TArg&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefActionWithNormalContext&lt;TContext, TArg&gt;, ClosureRefAction&lt;TContext, TArg&gt;&gt;(context, action);&#10;        &#10;        &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;ClosureFunc{TContext, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static ClosureFunc&lt;TContext, TResult&gt; Func&lt;TContext, TResult&gt;(TContext context, Func&lt;TContext, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, Func&lt;TContext, TResult&gt;, ClosureFunc&lt;TContext, TResult&gt;&gt;(context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;ClosureFunc{TContext, TArg, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static ClosureFunc&lt;TContext, TArg, TResult&gt; Func&lt;TContext, TArg, TResult&gt;(TContext context, Func&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, Func&lt;TContext, TArg, TResult&gt;, ClosureFunc&lt;TContext, TArg, TResult&gt;&gt;(context, func);&#10;    &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;ClosureRefFunc{TContext, TArg, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static ClosureRefFunc&lt;TContext, TArg, TResult&gt; RefFunc&lt;TContext, TArg, TResult&gt;(TContext context, RefFuncWithNormalContext&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefFuncWithNormalContext&lt;TContext, TArg, TResult&gt;, ClosureRefFunc&lt;TContext, TArg, TResult&gt;&gt;(context, func);&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Provides factory methods for creating mutating closure structs that encapsulate context and delegate logic.&#10;    /// &lt;/summary&gt;&#10;    public struct MutatingClosure {&#10;        /// &lt;summary&gt; Creates an &lt;see cref=&quot;MutatingClosureAction{TContext}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static MutatingClosureAction&lt;TContext&gt; Action&lt;TContext&gt;(TContext context, RefAction&lt;TContext&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefAction&lt;TContext&gt;, MutatingClosureAction&lt;TContext&gt;&gt;(context, action);&#10;    &#10;        /// &lt;summary&gt; Creates an &lt;see cref=&quot;MutatingClosureAction{TContext, TArg}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static MutatingClosureAction&lt;TContext, TArg&gt; Action&lt;TContext, TArg&gt;(TContext context, ActionWithRefContext&lt;TContext, TArg&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, ActionWithRefContext&lt;TContext, TArg&gt;, MutatingClosureAction&lt;TContext, TArg&gt;&gt;(context, action);&#10;    &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;MutatingClosureRefAction{TContext, TArg}&quot;/&gt; with the specified context and action. &lt;/summary&gt;&#10;        public static MutatingClosureRefAction&lt;TContext, TArg&gt; RefAction&lt;TContext, TArg&gt;(TContext context, RefAction&lt;TContext, TArg&gt; action) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefAction&lt;TContext, TArg&gt;, MutatingClosureRefAction&lt;TContext, TArg&gt;&gt;(context, action);&#10;        &#10;        &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;MutatingClosureFunc{TContext, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static MutatingClosureFunc&lt;TContext, TResult&gt; Func&lt;TContext, TResult&gt;(TContext context, RefFunc&lt;TContext, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefFunc&lt;TContext, TResult&gt;, MutatingClosureFunc&lt;TContext, TResult&gt;&gt;(context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;MutatingClosureFunc{TContext, TArg, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static MutatingClosureFunc&lt;TContext, TArg, TResult&gt; Func&lt;TContext, TArg, TResult&gt;(TContext context, FuncWithRefContext&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, FuncWithRefContext&lt;TContext, TArg, TResult&gt;, MutatingClosureFunc&lt;TContext, TArg, TResult&gt;&gt;(context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;MutatingClosureRefFunc{TContext, TArg, TResult}&quot;/&gt; with the specified context and function. &lt;/summary&gt;&#10;        public static MutatingClosureRefFunc&lt;TContext, TArg, TResult&gt; RefFunc&lt;TContext, TArg, TResult&gt;(TContext context, RefFunc&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            ClosureFactory.Create&lt;TContext, RefFunc&lt;TContext, TArg, TResult&gt;, MutatingClosureRefFunc&lt;TContext, TArg, TResult&gt;&gt;(context, func);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Provides factory methods for creating ref closure structs that encapsulate a context by reference and delegate logic,&#10;    /// &lt;/summary&gt;&#10;    public struct RefClosure {&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureAction{TContext}&quot;/&gt; with the specified ref context and action. &lt;/summary&gt;&#10;        public static RefClosureAction&lt;TContext&gt; Action&lt;TContext&gt;(ref TContext context, RefAction&lt;TContext&gt; action) =&gt;&#10;            new RefClosureAction&lt;TContext&gt;(ref context, action);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureAction{TContext, TArg}&quot;/&gt; with the specified ref context and action. &lt;/summary&gt;&#10;        public static RefClosureAction&lt;TContext, TArg&gt; Action&lt;TContext, TArg&gt;(ref TContext context, ActionWithRefContext&lt;TContext, TArg&gt; action) =&gt;&#10;            new RefClosureAction&lt;TContext, TArg&gt;(ref context, action);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureRefAction{TContext, TArg}&quot;/&gt; with the specified ref context and action. &lt;/summary&gt;&#10;        public static RefClosureRefAction&lt;TContext, TArg&gt; RefAction&lt;TContext, TArg&gt;(ref TContext context, RefAction&lt;TContext, TArg&gt; action) =&gt;&#10;            new RefClosureRefAction&lt;TContext, TArg&gt;(ref context, action);&#10;        &#10;        &#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureFunc{TContext, TResult}&quot;/&gt; with the specified ref context and function. &lt;/summary&gt;&#10;        public static RefClosureFunc&lt;TContext, TResult&gt; Func&lt;TContext, TResult&gt;(ref TContext context, RefFunc&lt;TContext, TResult&gt; func) =&gt;&#10;            new RefClosureFunc&lt;TContext, TResult&gt;(ref context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureFunc{TContext, TArg, TResult}&quot;/&gt; with the specified ref context and function. &lt;/summary&gt;&#10;        public static RefClosureFunc&lt;TContext, TArg, TResult&gt; Func&lt;TContext, TArg, TResult&gt;(ref TContext context, FuncWithRefContext&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            new RefClosureFunc&lt;TContext, TArg, TResult&gt;(ref context, func);&#10;&#10;        /// &lt;summary&gt; Creates a &lt;see cref=&quot;RefClosureRefFunc{TContext, TArg, TResult}&quot;/&gt; with the specified ref context and ref argument function. &lt;/summary&gt;&#10;        public static RefClosureRefFunc&lt;TContext, TArg, TResult&gt; RefFunc&lt;TContext, TArg, TResult&gt;(ref TContext context, RefFunc&lt;TContext, TArg, TResult&gt; func) =&gt;&#10;            new RefClosureRefFunc&lt;TContext, TArg, TResult&gt;(ref context, func);&#10;    }&#10;    &#10;    public static class ClosureManager {&#10;        public static event Action? OnCacheClear;&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Clears all caches in the system.&#10;        /// &lt;/summary&gt;&#10;        public static void ClearCache() {&#10;            OnCacheClear?.Invoke();&#10;        }&#10;    }&#10;    &#10;    public static class ClosureExtensions {&#10;        /// &lt;summary&gt;&#10;        /// Converts a &lt;see cref=&quot;ClosureAction{TContext}&quot;/&gt; to a parameterless &lt;see cref=&quot;Action&quot;/&gt; delegate.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;typeparam name=&quot;TContext&quot;&gt;The type of the captured context.&lt;/typeparam&gt;&#10;        /// &lt;param name=&quot;closure&quot;&gt;The closure to convert.&lt;/param&gt;&#10;        /// &lt;returns&gt;An &lt;see cref=&quot;Action&quot;/&gt; that invokes the closure with its captured context.&lt;/returns&gt;&#10;        public static Action AsAction&lt;TContext&gt;(this ClosureAction&lt;TContext&gt; closure) =&gt; ClosureToAction&lt;TContext&gt;.AsAction(closure);&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts a &lt;see cref=&quot;ClosureAction{TContext, TArg}&quot;/&gt; to an &lt;see cref=&quot;Action{TArg}&quot;/&gt; delegate.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;typeparam name=&quot;TContext&quot;&gt;The type of the captured context.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument.&lt;/typeparam&gt;&#10;        /// &lt;param name=&quot;closure&quot;&gt;The closure to convert.&lt;/param&gt;&#10;        /// &lt;returns&gt;An &lt;see cref=&quot;Action{TArg}&quot;/&gt; that invokes the closure with its captured context and the provided argument.&lt;/returns&gt;&#10;        public static Action&lt;TArg&gt; AsAction&lt;TContext, TArg&gt;(this ClosureAction&lt;TContext, TArg&gt; closure) =&gt; ClosureToAction&lt;TContext, TArg&gt;.AsAction(closure);&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts a &lt;see cref=&quot;ClosureFunc{TContext, TResult}&quot;/&gt; to a parameterless &lt;see cref=&quot;Func{TResult}&quot;/&gt; delegate.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;typeparam name=&quot;TContext&quot;&gt;The type of the captured context.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TResult&quot;&gt;The return type of the function.&lt;/typeparam&gt;&#10;        /// &lt;param name=&quot;closure&quot;&gt;The closure to convert.&lt;/param&gt;&#10;        /// &lt;returns&gt;A &lt;see cref=&quot;Func{TResult}&quot;/&gt; that invokes the closure with its captured context and returns the result.&lt;/returns&gt;&#10;        public static Func&lt;TResult&gt; AsFunc&lt;TContext, TResult&gt;(this ClosureFunc&lt;TContext, TResult&gt; closure) =&gt; ClosureToFunc&lt;TContext, TResult&gt;.AsFunc(closure);&#10;&#10;        /// &lt;summary&gt;&#10;        /// Converts a &lt;see cref=&quot;ClosureFunc{TContext, TArg, TResult}&quot;/&gt; to a &lt;see cref=&quot;Func{TArg, TResult}&quot;/&gt; delegate.&#10;        /// &lt;/summary&gt;&#10;        /// &lt;typeparam name=&quot;TContext&quot;&gt;The type of the captured context.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TArg&quot;&gt;The type of the argument.&lt;/typeparam&gt;&#10;        /// &lt;typeparam name=&quot;TResult&quot;&gt;The return type of the function.&lt;/typeparam&gt;&#10;        /// &lt;param name=&quot;closure&quot;&gt;The closure to convert.&lt;/param&gt;&#10;        /// &lt;returns&gt;A &lt;see cref=&quot;Func{TArg, TResult}&quot;/&gt; that invokes the closure with its captured context and the provided argument, returning the result.&lt;/returns&gt;&#10;        public static Func&lt;TArg, TResult&gt; AsFunc&lt;TContext, TArg, TResult&gt;(this ClosureFunc&lt;TContext, TArg, TResult&gt; closure) =&gt; ClosureToFunc&lt;TContext, TArg, TResult&gt;.AsFunc(closure);&#10;    }&#10;    &#10;    // ReSharper disable ConvertClosureToMethodGroup&#10;    internal static class ClosureToAction&lt;TContext&gt; {&#10;        static readonly ConcurrentDictionary&lt;ClosureAction&lt;TContext&gt;, Action&gt; s_closureToActionMap = new ();&#10;        static ClosureToAction() =&gt; ClosureManager.OnCacheClear += () =&gt; s_closureToActionMap.Clear();&#10;        public static Action AsAction(ClosureAction&lt;TContext&gt; closure) =&gt; s_closureToActionMap.GetOrAdd(closure, c =&gt; () =&gt; c.Invoke());&#10;    }&#10;    &#10;    internal static class ClosureToAction&lt;TContext, TArg&gt; {&#10;        static readonly ConcurrentDictionary&lt;ClosureAction&lt;TContext, TArg&gt;, Action&lt;TArg&gt;&gt; s_closureToActionMap = new ();&#10;        static ClosureToAction() =&gt; ClosureManager.OnCacheClear += () =&gt; s_closureToActionMap.Clear();&#10;        public static Action&lt;TArg&gt; AsAction(ClosureAction&lt;TContext, TArg&gt; closure) =&gt; s_closureToActionMap.GetOrAdd(closure, c =&gt; arg =&gt; c.Invoke(arg));&#10;    }&#10;    &#10;    internal static class ClosureToFunc&lt;TContext, TResult&gt; {&#10;        static readonly ConcurrentDictionary&lt;ClosureFunc&lt;TContext, TResult&gt;, Func&lt;TResult&gt;&gt; s_closureToFuncMap = new ();&#10;        static ClosureToFunc() =&gt; ClosureManager.OnCacheClear += () =&gt; s_closureToFuncMap.Clear();&#10;        public static Func&lt;TResult&gt; AsFunc(ClosureFunc&lt;TContext, TResult&gt; closure) =&gt; s_closureToFuncMap.GetOrAdd(closure, c =&gt; () =&gt; c.Invoke());&#10;    }&#10;    &#10;    internal static class ClosureToFunc&lt;TContext, TArg, TResult&gt; {&#10;        static readonly ConcurrentDictionary&lt;ClosureFunc&lt;TContext, TArg, TResult&gt;, Func&lt;TArg, TResult&gt;&gt; s_closureToFuncMap = new ();&#10;        static ClosureToFunc() =&gt; ClosureManager.OnCacheClear += () =&gt; s_closureToFuncMap.Clear();&#10;        public static Func&lt;TArg, TResult&gt; AsFunc(ClosureFunc&lt;TContext, TArg, TResult&gt; closure) =&gt; s_closureToFuncMap.GetOrAdd(closure, c =&gt; arg =&gt; c.Invoke(arg));&#10;    }&#10;    // ReSharper restore ConvertClosureToMethodGroup&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Closures/Result.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Closures/Result.cs" />
              <option name="updatedContent" value="&#10;/// &lt;summary&gt;&#10;/// Represents the result of an operation, indicating success or failure and an optional exception.&#10;/// &lt;/summary&gt;&#10;public readonly record struct Result {&#10;    /// &lt;summary&gt;&#10;    /// Indicates whether the operation was successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly bool IsSuccess;&#10;    /// &lt;summary&gt;&#10;    /// The exception associated with a failed operation, or &lt;c&gt;null&lt;/c&gt; if successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly Exception? Exception;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Implicitly converts the result to a boolean indicating success.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;result&quot;&gt;The result to convert.&lt;/param&gt;&#10;    public static implicit operator bool(Result result) =&gt; result.IsSuccess;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;Result&quot;/&gt; struct.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;isSuccess&quot;&gt;Whether the operation was successful.&lt;/param&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception if the operation failed, or &lt;c&gt;null&lt;/c&gt; if successful.&lt;/param&gt;&#10;    Result(bool isSuccess, Exception? ex = null) {&#10;        IsSuccess = isSuccess;&#10;        Exception = ex;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a successful result.&#10;    /// &lt;/summary&gt;&#10;    public static Result Success() =&gt; new(true);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a failed result with the specified exception.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception representing the failure.&lt;/param&gt;&#10;    public static Result Failure(Exception ex) =&gt; new(false, ex);&#10;}&#10;&#10;/// &lt;summary&gt;&#10;/// Represents the result of an operation that returns a value, indicating success or failure, the value, and an optional exception.&#10;/// &lt;/summary&gt;&#10;/// &lt;typeparam name=&quot;T&quot;&gt;The type of the value returned by the operation.&lt;/typeparam&gt;&#10;public readonly record struct Result&lt;T&gt; {&#10;    /// &lt;summary&gt;&#10;    /// Indicates whether the operation was successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly bool IsSuccess;&#10;    /// &lt;summary&gt;&#10;    /// The value returned by the operation if successful, or &lt;c&gt;default&lt;/c&gt; if failed.&#10;    /// &lt;/summary&gt;&#10;    public readonly T? Value;&#10;    /// &lt;summary&gt;&#10;    /// The exception associated with a failed operation, or &lt;c&gt;null&lt;/c&gt; if successful.&#10;    /// &lt;/summary&gt;&#10;    public readonly Exception? Exception;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Implicitly converts the result to a boolean indicating success.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;result&quot;&gt;The result to convert.&lt;/param&gt;&#10;    public static implicit operator bool(Result&lt;T&gt; result) =&gt; result.IsSuccess;&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Initializes a new instance of the &lt;see cref=&quot;Result{T}&quot;/&gt; struct.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;isSuccess&quot;&gt;Whether the operation was successful.&lt;/param&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value returned by the operation, or &lt;c&gt;default&lt;/c&gt; if failed.&lt;/param&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception if the operation failed, or &lt;c&gt;null&lt;/c&gt; if successful.&lt;/param&gt;&#10;    Result(bool isSuccess, T? value = default, Exception? ex = null) {&#10;        IsSuccess = isSuccess;&#10;        Value = value;&#10;        Exception = ex;&#10;    }&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a successful result with the specified value.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;value&quot;&gt;The value returned by the operation.&lt;/param&gt;&#10;    public static Result&lt;T&gt; Success(T value) =&gt; new(true, value);&#10;&#10;    /// &lt;summary&gt;&#10;    /// Creates a failed result with the specified exception.&#10;    /// &lt;/summary&gt;&#10;    /// &lt;param name=&quot;ex&quot;&gt;The exception representing the failure.&lt;/param&gt;&#10;    public static Result&lt;T&gt; Failure(Exception ex) =&gt; new(false, default, ex);&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>