<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ClosureTests/ActionTests/AnonymousClosure/AnonymousClosureTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/ActionTests/AnonymousClosure/AnonymousClosureTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.ActionTests.AnonymousClosure;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    // Normal Actions&#10;    [Test]&#10;    public void ClosureActionAsAnonymousAndBack() {&#10;        int expected = 10;&#10;        int received = 0;&#10;        &#10;        var closureAction = Closure.Action(expected, context =&gt; received = context);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int&gt;().Invoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context value.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void ClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    [Test]&#10;    public void ClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, ref int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureRefAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    // Mutating Actions&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.ActionTests.AnonymousClosure;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    // Normal Actions&#10;    [Test]&#10;    public void ClosureActionAsAnonymousAndBack() {&#10;        int expected = 10;&#10;        int received = 0;&#10;        &#10;        var closureAction = Closure.Action(expected, context =&gt; received = context);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int&gt;().Invoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context value.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void ClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    [Test]&#10;    public void ClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, ref int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureRefAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    // Mutating Actions&#10;    [Test]&#10;    public void MutatingClosureActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int expected = context + 5;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c) =&gt; c += 5, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureAction&lt;int&gt;().Invoke();&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureAction did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void MutatingClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 7;&#10;        int expected = context + arg;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c, int a) =&gt; c += a, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureActionWithArg did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void MutatingClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c, ref int a) =&gt; c += a, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureRefAction&lt;int, int&gt;().Invoke(ref arg);&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureRefAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureRefAction did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction))]&#10;public class AnonymousClosureActionTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    &#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        a.Invoke();&#10;        &#10;        var b = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction))]&#10;public class AnonymousClosureActionTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    &#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx) =&gt; ctx += addition,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke();&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureAction_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;&#10;        var anon = AnonymousClosure.Action(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx) =&gt; ctx.testContext.Value = ctx.value = expected,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;        Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        a.Invoke();&#10;        &#10;        var b = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionWithArgTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureActionWithArgTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction&lt;&gt;))]&#10;public class AnonymousClosureActionWithArgTest {&#10;&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesContext() {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; ctx.testContext.Value = ctx.expected);&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; ctx += addition,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; ctx.testContext.Value = ctx.value = expected,&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Anonymous tests&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx * arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(15));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx * arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(20));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        int arg = 1;&#10;        a.Invoke(arg);&#10;&#10;        var b = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureAction&lt;&gt;))]&#10;public class AnonymousClosureActionWithArgTest {&#10;&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesContext() {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; { Assert.That(ctx, Is.EqualTo(expected)); });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; { ctx.testContext.Value = ctx.expected; });&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; { Assert.That(ctx + a, Is.EqualTo(expected)); });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; { Assert.That(ctx + a, Is.EqualTo(expected)); });&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; { val += ctx; });&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; { val += ctx; });&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingContext_RetainsModifiedContext() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; { ctx += addition; },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureActionWithArg_MutatingTupleContext_RetainsModifiedContext() {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; { ctx.testContext.Value = ctx.value = expected; },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Anonymous tests&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { calledWith = ctx * arg; };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(15));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { calledWith = ctx * arg; };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(20));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { throw new InvalidCastException(&quot;fail&quot;); };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        var result = anon.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void TryInvoke_ByRef_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { throw new InvalidCastException(&quot;fail&quot;); };&#10;&#10;        var anon = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = anon.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; { };&#10;&#10;        var a = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;        // Invoke to cache the invoker delegate (shouldn't affect equality)&#10;        int arg = 1;&#10;        a.Invoke(arg);&#10;&#10;        var b = AnonymousClosure.Action&lt;int&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureCreationTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureCreationTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureCreationTests&#10;{&#10;    [Test]&#10;    public void AnonymousClosure_Action_CreatesCorrectly()&#10;    {&#10;        int context = 42;&#10;        Action&lt;int&gt; action = _ =&gt; { };&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_WithArg_CreatesCorrectly()&#10;    {&#10;        int context = 7;&#10;        Action&lt;int, string&gt; action = (_, __) =&gt; { };&#10;        var anon = AnonymousClosure.Action&lt;string&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 5;&#10;        RefAction&lt;int&gt; action = (ref int x) =&gt; x++;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_WithArg_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 3;&#10;        ActionWithRefContext&lt;int, string&gt; action = (ref int x, string s) =&gt; x += s.Length;&#10;        var anon = AnonymousClosure.Action&lt;string&gt;(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_CreatesCorrectly()&#10;    {&#10;        int context = 10;&#10;        Func&lt;int, string&gt; func = x =&gt; x.ToString();&#10;        var anon = AnonymousClosure.Func&lt;string&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_WithArg_CreatesCorrectly()&#10;    {&#10;        int context = 8;&#10;        Func&lt;int, string, string&gt; func = (x, s) =&gt; (x + s.Length).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string, string&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 2;&#10;        RefFunc&lt;int, string&gt; func = (ref int x) =&gt; (++x).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_WithArg_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 4;&#10;        FuncWithRefContext&lt;int, string, string&gt; func = (ref int x, string s) =&gt; (x += s.Length).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string, string&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureCreationTests&#10;{&#10;    [Test]&#10;    public void AnonymousClosure_Action_CreatesCorrectly()&#10;    {&#10;        int context = 42;&#10;        Action&lt;int&gt; action = _ =&gt; { };&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_WithArg_CreatesCorrectly()&#10;    {&#10;        int context = 7;&#10;        Action&lt;int, string&gt; action = (_, __) =&gt; { };&#10;        var anon = AnonymousClosure.Action&lt;string&gt;(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 5;&#10;        RefAction&lt;int&gt; action = (ref int x) =&gt; x++;&#10;        var anon = AnonymousClosure.Action(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_WithArg_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 3;&#10;        ActionWithRefContext&lt;int, string&gt; action = (ref int x, string s) =&gt; x += s.Length;&#10;        var anon = AnonymousClosure.Action&lt;string&gt;(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_CreatesCorrectly()&#10;    {&#10;        int context = 10;&#10;        Func&lt;int, string&gt; func = x =&gt; x.ToString();&#10;        var anon = AnonymousClosure.Func&lt;string&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_WithArg_CreatesCorrectly()&#10;    {&#10;        int context = 8;&#10;        Func&lt;int, string, string&gt; func = (x, s) =&gt; (x + s.Length).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string, string&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 2;&#10;        RefFunc&lt;int, string&gt; func = (ref int x) =&gt; (++x).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_WithArg_Mutating_CreatesCorrectly()&#10;    {&#10;        int context = 4;&#10;        FuncWithRefContext&lt;int, string, string&gt; func = (ref int x, string s) =&gt; (x += s.Length).ToString();&#10;        var anon = AnonymousClosure.Func&lt;string, string&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Create_CreatesCorrectly()&#10;    {&#10;        int context = 123;&#10;        Action&lt;int&gt; action = _ =&gt; { };&#10;        var anon = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Create_WithMutatingBehaviour_CreatesCorrectly()&#10;    {&#10;        int context = 456;&#10;        RefAction&lt;int&gt; action = (ref int x) =&gt; x++;&#10;        var anon = AnonymousClosure.Create(AnonymousValue.From(context), action, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(action));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Create_GenericDelegate_CreatesCorrectly()&#10;    {&#10;        int context = 789;&#10;        Func&lt;int, string&gt; func = x =&gt; x.ToString();&#10;        var anon = AnonymousClosure.Create&lt;Func&lt;int, string&gt;&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Reset));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Create_GenericDelegate_WithMutatingBehaviour_CreatesCorrectly()&#10;    {&#10;        int context = 321;&#10;        RefFunc&lt;int, string&gt; func = (ref int x) =&gt; (++x).ToString();&#10;        var anon = AnonymousClosure.Create&lt;RefFunc&lt;int, string&gt;&gt;(AnonymousValue.From(context), func, MutatingBehaviour.Mutate);&#10;&#10;        Assert.Multiple(() =&gt;&#10;        {&#10;            Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(context));&#10;            Assert.That(anon.Delegate, Is.EqualTo(func));&#10;            Assert.That(anon.MutatingBehaviour, Is.EqualTo(MutatingBehaviour.Mutate));&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureExtensionsTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureExtensionsTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureExtensions))]&#10;public class AnonymousClosureExtensionsTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureExtensions))]&#10;public class AnonymousClosureExtensionsTest {&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;&gt;))]&#10;public class AnonymousClosureFuncTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx;&#10;        });&#10;&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From((testContext, expected)),&#10;            ((TestClass testContext, int expected) ctx) =&gt; {&#10;                ctx.testContext.Value = ctx.expected;&#10;                return ctx.expected;&#10;            });&#10;&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReturnsExpectedValue() {&#10;        int context = 10;&#10;        int expected = context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 2);&#10;&#10;        int result = anon.Invoke();&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx + 1;&#10;&#10;        var a = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;&gt;))]&#10;public class AnonymousClosureFuncTest {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx;&#10;        });&#10;&#10;        anon.Invoke();&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From((testContext, expected)),&#10;            ((TestClass testContext, int expected) ctx) =&gt; {&#10;                ctx.testContext.Value = ctx.expected;&#10;                return ctx.expected;&#10;            });&#10;&#10;        anon.Invoke();&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_ReturnsExpectedValue() {&#10;        int context = 10;&#10;        int expected = context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 2);&#10;&#10;        int result = anon.Invoke();&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = anon.TryInvoke();&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvokeBool_ReturnsTrueAndResult_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        bool success = anon.TryInvoke(out int result);&#10;        Assert.That(success, Is.True);&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_TryInvokeBool_ReturnsFalseAndDefault_OnException() {&#10;        int context = 1;&#10;        var anon = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context),&#10;            (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        bool success = anon.TryInvoke(out int result);&#10;        Assert.That(success, Is.False);&#10;        Assert.That(result, Is.EqualTo(default(int)));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFunc_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx + 1;&#10;&#10;        var a = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Func&lt;int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncWithArgTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureFuncWithArgTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;,&gt;))]&#10;public class AnonymousClosureFuncWithArgTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousClosureFunc&lt;,&gt;))]&#10;public class AnonymousClosureFuncWithArgTest&#10;{&#10;    class TestClass&#10;    {&#10;        public int Value { get; set; }&#10;    }&#10;&#10;    // Default tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesContext()&#10;    {&#10;        int context = 5;&#10;        int arg = 7;&#10;        int expected = 5;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; {&#10;            Assert.That(ctx, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesTupleContext_AndModifiesTestContextValue()&#10;    {&#10;        int expected = 5;&#10;        int arg = 1;&#10;        var testContext = new TestClass();&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx, int a) =&gt; {&#10;            ctx.testContext.Value = ctx.expected;&#10;            return ctx.expected + a;&#10;        });&#10;        anon.Invoke(arg);&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesArg()&#10;    {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; {&#10;            Assert.That(ctx + a, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(arg);&#10;    }&#10;&#10;    // Ref argument tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReceivesRefArg()&#10;    {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int a) =&gt; {&#10;            Assert.That(ctx + a, Is.EqualTo(expected));&#10;            return ctx + a;&#10;        });&#10;        anon.Invoke(ref arg);&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ModifiesRefArgValue()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; {&#10;            val += ctx;&#10;            return val;&#10;        });&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ModifiesRefArgValue_MultipleInvocations()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; {&#10;            val += ctx;&#10;            return val;&#10;        });&#10;        anon.Invoke(ref arg);&#10;        anon.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Mutating context tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_MutatingContext_RetainsModifiedContext()&#10;    {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int addition = 7;&#10;        int expected = context + addition;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(&#10;            AnonymousValue.From(context),&#10;            (ref int ctx, int a) =&gt; {&#10;                ctx += addition;&#10;                return ctx + a;&#10;            },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;        Assert.That(anon.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_MutatingTupleContext_RetainsModifiedContext()&#10;    {&#10;        var testContext = new TestClass();&#10;        int expected = 42;&#10;        int arg = 0;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(&#10;            AnonymousValue.From((testContext, 0)),&#10;            (ref (TestClass testContext, int value) ctx, int a) =&gt; {&#10;                ctx.testContext.Value = ctx.value = expected;&#10;                return ctx.value + a;&#10;            },&#10;            MutatingBehaviour.Mutate&#10;        );&#10;        anon.Invoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(testContext.Value, Is.EqualTo(expected));&#10;            Assert.That(anon.Context.As&lt;(TestClass, int)&gt;().Item2, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    // Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_ReturnsExpectedValue()&#10;    {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;        int result = anon.Invoke(arg);&#10;        Assert.That(result, Is.EqualTo(expected));&#10;    }&#10;&#10;    // Anonymous Func tests&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvoke_ReturnsSuccess_OnValidCall()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;&#10;        var result = anon.TryInvoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvoke_ReturnsFailure_OnException()&#10;    {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;));&#10;&#10;        var result = anon.TryInvoke(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvokeBool_ReturnsTrueAndResult_OnValidCall()&#10;    {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context * arg;&#10;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx * a);&#10;&#10;        bool success = anon.TryInvoke(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.True);&#10;            Assert.That(result, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_TryInvokeBool_ReturnsFalseAndDefault_OnException()&#10;    {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var anon = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), (int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;));&#10;&#10;        bool success = anon.TryInvoke(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.False);&#10;            Assert.That(result, Is.EqualTo(default(int)));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosureFuncWithArg_Equals_And_HashCode_Work()&#10;    {&#10;        int context = 7;&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;&#10;        var a = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), func);&#10;        a.Invoke(1);&#10;&#10;        var b = AnonymousClosure.Func&lt;int, int&gt;(AnonymousValue.From(context), func);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousClosureTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    // Default tests&#10;        &#10;    [Test]&#10;    public void Action_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        closure.Invoke();&#10;    }&#10;        &#10;    [Test]&#10;    public void Action_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;&#10;        var testContext = new TestClass();&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; { &#10;            ctx.testContext.Value = ctx.expected;&#10;        });&#10;        closure.Invoke();&#10;&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(arg);&#10;    }&#10;    &#10;    // Ref argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(ref arg);&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Mutating tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourMutate_RetainsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context + addition;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Mutate);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourReset_ResetsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Reset);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Func Tests&#10;&#10;    [Test]&#10;    public void Func_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx);&#10;        var result = closure.Invoke&lt;int&gt;();&#10;        &#10;        Assert.That(result, Is.EqualTo(context), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(argument);&#10;        &#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func ref arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithRefArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(ref argument);&#10;&#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Anonymous Action Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Func Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Is_Works() {&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(42), (int ctx) =&gt; { });&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(closure.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True);&#10;            Assert.That(closure.Is&lt;MutatingClosureFunc&lt;int, int&gt;&gt;(), Is.False);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    class TestClass {&#10;        public int Value { get; set; }&#10;    }&#10;    // Default tests&#10;        &#10;    [Test]&#10;    public void Action_ReceivesContext() {&#10;        int context = 5;&#10;        int expected = 5;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; Assert.That(ctx, Is.EqualTo(expected)));&#10;        closure.Invoke();&#10;    }&#10;        &#10;    [Test]&#10;    public void Action_ReceivesTupleContext_AndModifiesTestContextValue() {&#10;        int expected = 5;&#10;&#10;        var testContext = new TestClass();&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From((testContext, expected)), ((TestClass testContext, int expected) ctx) =&gt; { &#10;            ctx.testContext.Value = ctx.expected;&#10;        });&#10;        closure.Invoke();&#10;&#10;        Assert.That(testContext.Value, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_ReceivesArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(arg);&#10;    }&#10;    &#10;    // Ref argument tests&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ReceivesRefArg() {&#10;        int context = 5;&#10;        int arg = 2;&#10;        int expected = context + arg;&#10;            &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; Assert.That(ctx + a, Is.EqualTo(expected)));&#10;        closure.Invoke(ref arg);&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithRefArg_ModifiesRefArgValue_MultipleInvocations() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = arg + context * 2;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;RefActionWithNormalContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (int ctx, ref int val) =&gt; val += ctx);&#10;        closure.Invoke(ref arg);&#10;        closure.Invoke(ref arg);&#10;        Assert.That(arg, Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Mutating tests&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourMutate_RetainsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context + addition;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Mutate);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    [Test]&#10;    public void ActionWithArg_MutatingBehaviourReset_ResetsModifiedContext() {&#10;        int context = 5;&#10;        int addition = 3;&#10;        int expected = context;&#10;            &#10;        var closure = AnonymousClosure.Create&lt;ActionWithRefContext&lt;int, int&gt;&gt;(AnonymousValue.From(context), (ref int ctx, int arg) =&gt; ctx += arg, MutatingBehaviour.Reset);&#10;        closure.Invoke(addition);&#10;            &#10;        Assert.That(closure.Context.As&lt;int&gt;(), Is.EqualTo(expected));&#10;    }&#10;    &#10;    // Func Tests&#10;&#10;    [Test]&#10;    public void Func_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx);&#10;        var result = closure.Invoke&lt;int&gt;();&#10;        &#10;        Assert.That(result, Is.EqualTo(context), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;        &#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(argument);&#10;        &#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Func ref arg Tests&#10;&#10;    [Test]&#10;    public void FuncWithRefArg_ReturnsCorrectValue() {&#10;        var context = 5;&#10;        var argument = 5;&#10;        var expected = context + argument;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int arg) =&gt; ctx + arg);&#10;        var result = closure.Invoke&lt;int, int&gt;(ref argument);&#10;&#10;        Assert.That(result, Is.EqualTo(expected), &quot;Anonymous closure did not return the expected value.&quot;);&#10;    }&#10;    &#10;    // Anonymous Action Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; calledWith = ctx * 2;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(10));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int&gt; action = ctx =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Func Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int expected = context * 3;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx) =&gt; ctx * 3);&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (Func&lt;int, int&gt;)((int ctx) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Anonymous Tests&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Is_Works() {&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(42), (int ctx) =&gt; { });&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(closure.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True);&#10;            Assert.That(closure.Is&lt;MutatingClosureFunc&lt;int, int&gt;&gt;(), Is.False);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Equals_And_HashCode_Work() {&#10;        int context = 7;&#10;        Action&lt;int&gt; action = ctx =&gt; { };&#10;&#10;        var a = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;        a.Invoke();&#10;&#10;        var b = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a.GetHashCode(), Is.EqualTo(b.GetHashCode()));&#10;    }&#10;&#10;    // TryInvoke with arg&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke(3);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(8));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        var result = closure.TryInvoke(2);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // TryInvoke with ref arg&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithRefArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        int arg = 4;&#10;        var result = closure.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(calledWith, Is.EqualTo(9));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Action_TryInvoke_WithRefArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; throw new InvalidCastException(&quot;fail&quot;);&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), action);&#10;&#10;        int arg = 2;&#10;        var result = closure.TryInvoke(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke with arg&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx + a);&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke with ref arg&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithRefArg_ReturnsSuccess_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, ref int a) =&gt; ctx + a);&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.True);&#10;            Assert.That(result.Value, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvoke_WithRefArg_ReturnsFailure_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        var result = closure.TryInvoke&lt;int, int&gt;(ref arg);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(result.IsSuccess, Is.False);&#10;            Assert.That(result.Exception, Is.TypeOf&lt;InvalidCastException&gt;());&#10;        });&#10;    }&#10;&#10;    // Func TryInvoke bool out result&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvokeBool_WithArg_ReturnsTrueAndResult_OnValidCall() {&#10;        int context = 5;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context), (int ctx, int a) =&gt; ctx + a);&#10;&#10;        bool success = closure.TryInvoke&lt;int, int&gt;(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.True);&#10;            Assert.That(result, Is.EqualTo(expected));&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void AnonymousClosure_Func_TryInvokeBool_WithArg_ReturnsFalseAndDefault_OnException() {&#10;        int context = 1;&#10;        int arg = 2;&#10;        var closure = AnonymousClosure.Create(AnonymousValue.From(context),&#10;            (Func&lt;int, int, int&gt;)((int ctx, int a) =&gt; throw new InvalidCastException(&quot;fail&quot;)));&#10;&#10;        bool success = closure.TryInvoke&lt;int, int&gt;(arg, out int result);&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(success, Is.False);&#10;            Assert.That(result, Is.EqualTo(default(int)));&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousHelperTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousHelperTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousHelper))]&#10;public class AnonymousHelperTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;using System;&#10;using System.Linq;&#10;using System.Reflection;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousHelper))]&#10;public class AnonymousHelperTest&#10;{&#10;    private class DummyClosure : IClosure&lt;int, Action&lt;int&gt;&gt;&#10;    {&#10;        public int Context { get; }&#10;        public Action&lt;int&gt; Action { get; }&#10;        public DummyClosure(int ctx, Action&lt;int&gt; action) { Context = ctx; Action = action; }&#10;    }&#10;&#10;    private class DummyAnonymousClosure : IAnonymousClosure&#10;    {&#10;        public AnonymousValue Context { get; set; }&#10;        public Delegate Delegate { get; set; }&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceType_ReturnsCorrectInterface()&#10;    {&#10;        var type = AnonymousHelper.GetInterfaceType&lt;DummyClosure&gt;();&#10;        Assert.That(type, Is.EqualTo(typeof(IClosure&lt;int, Action&lt;int&gt;&gt;)));&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceType_ThrowsIfNoInterface()&#10;    {&#10;        Assert.Throws&lt;InvalidOperationException&gt;(() =&gt; AnonymousHelper.GetInterfaceType&lt;AnonymousHelperTest&gt;());&#10;    }&#10;&#10;    [Test]&#10;    public void GetInterfaceGenericArguments_ReturnsCorrectArguments()&#10;    {&#10;        var iface = typeof(IClosure&lt;int, Action&lt;int&gt;&gt;);&#10;        var args = AnonymousHelper.GetInterfaceGenericArguments(iface);&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(Action&lt;int&gt;) }));&#10;    }&#10;&#10;    [Test]&#10;    public void CanConvert_ReturnsTrueForMatchingTypes()&#10;    {&#10;        var anon = new DummyAnonymousClosure&#10;        {&#10;            Context = AnonymousValue.Int(42),&#10;            Delegate = new Action&lt;int&gt;(_ =&gt; { })&#10;        };&#10;        Assert.That(AnonymousHelper.CanConvert&lt;DummyClosure, DummyAnonymousClosure&gt;(anon), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void CanConvert_ReturnsFalseForMismatchedTypes()&#10;    {&#10;        var anon = new DummyAnonymousClosure&#10;        {&#10;            Context = AnonymousValue.Char('c'),&#10;            Delegate = new Action&lt;string&gt;(_ =&gt; { })&#10;        };&#10;        Assert.That(AnonymousHelper.CanConvert&lt;DummyClosure, DummyAnonymousClosure&gt;(anon), Is.False);&#10;    }&#10;&#10;    [TestCase(typeof(InvalidOperationException), ExpectedResult = false)]&#10;    [TestCase(typeof(InvalidCastException), ExpectedResult = false)]&#10;    [TestCase(typeof(ArgumentException), ExpectedResult = false)]&#10;    [TestCase(typeof(NullReferenceException), ExpectedResult = true)]&#10;    public bool ShouldThrow_Works(Type exceptionType)&#10;    {&#10;        var ex = (Exception)Activator.CreateInstance(exceptionType)!;&#10;        return AnonymousHelper.ShouldThrow(ex);&#10;    }&#10;&#10;    [Test]&#10;    public void IsAction_TrueForAction()&#10;    {&#10;        Action a = () =&gt; { };&#10;        Assert.That(AnonymousHelper.IsAction(a), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void IsAction_FalseForFunc()&#10;    {&#10;        Func&lt;int&gt; f = () =&gt; 1;&#10;        Assert.That(AnonymousHelper.IsAction(f), Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void IsFunc_TrueForFunc()&#10;    {&#10;        Func&lt;int&gt; f = () =&gt; 1;&#10;        Assert.That(AnonymousHelper.IsFunc(f), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void IsFunc_FalseForAction()&#10;    {&#10;        Action a = () =&gt; { };&#10;        Assert.That(AnonymousHelper.IsFunc(a), Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void GetGenericArguments_Delegate_ReturnsCorrectTypes()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        var args = AnonymousHelper.GetGenericArguments(del);&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(string) }));&#10;    }&#10;&#10;    [Test]&#10;    public void GetGenericArguments_Type_ReturnsCorrectTypes()&#10;    {&#10;        var args = AnonymousHelper.GetGenericArguments(typeof(Action&lt;int, string&gt;));&#10;        Assert.That(args, Is.EqualTo(new[] { typeof(int), typeof(string) }));&#10;    }&#10;&#10;    [Test]&#10;    public void HasArgOfType_ReturnsTrueIfArgMatches()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        Assert.That(AnonymousHelper.HasArgOfType&lt;string&gt;(del), Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void HasArgOfType_ReturnsFalseIfArgDoesNotMatch()&#10;    {&#10;        Action&lt;int, string&gt; del = (i, s) =&gt; { };&#10;        Assert.That(AnonymousHelper.HasArgOfType&lt;double&gt;(del), Is.False);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousInvokersTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousInvokersTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousInvokers))]&#10;public class AnonymousInvokersTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;using System;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousInvokers))]&#10;public class AnonymousInvokersTest&#10;{&#10;    [Test]&#10;    public void GetActionInvoker_InvokesNormalAction()&#10;    {&#10;        int called = 0;&#10;        Action&lt;int&gt; action = ctx =&gt; called = ctx + 1;&#10;        var anon = AnonymousValue.From(41);&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Reset);&#10;&#10;        Assert.That(called, Is.EqualTo(42));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(41)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvoker_InvokesMutatingAction()&#10;    {&#10;        Action&lt;ref int&gt; action = (ref int ctx) =&gt; ctx += 10;&#10;        var anon = AnonymousValue.From(5);&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Mutate);&#10;&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(15));&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvokerTArg_InvokesNormalActionWithArg()&#10;    {&#10;        int called = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; called = ctx + arg;&#10;        var anon = AnonymousValue.From(10);&#10;        int arg = 5;&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker&lt;int&gt;(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Reset, ref arg);&#10;&#10;        Assert.That(called, Is.EqualTo(15));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvokerTArg_InvokesMutatingActionWithArg()&#10;    {&#10;        ActionWithRefContext&lt;int, int&gt; action = (ref int ctx, int arg) =&gt; ctx += arg;&#10;        var anon = AnonymousValue.From(7);&#10;        int arg = 3;&#10;&#10;        var invoker = AnonymousInvokers.GetActionInvoker&lt;int&gt;(action);&#10;        invoker(action, ref anon, MutatingBehaviour.Mutate, ref arg);&#10;&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_InvokesNormalFunc()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx * 2;&#10;        var anon = AnonymousValue.From(21);&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Reset);&#10;&#10;        Assert.That(result, Is.EqualTo(42));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(21)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_InvokesMutatingFunc()&#10;    {&#10;        RefFunc&lt;int, int&gt; func = (ref int ctx) =&gt; ++ctx;&#10;        var anon = AnonymousValue.From(99);&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Mutate);&#10;&#10;        Assert.That(result, Is.EqualTo(100));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(100));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_InvokesNormalFuncWithArg()&#10;    {&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;        var anon = AnonymousValue.From(10);&#10;        int arg = 5;&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int, int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Reset, ref arg);&#10;&#10;        Assert.That(result, Is.EqualTo(15));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(10)); // context not mutated&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_InvokesMutatingFuncWithArg()&#10;    {&#10;        RefFunc&lt;int, int, int&gt; func = (ref int ctx, ref int arg) =&gt; ctx += arg;&#10;        var anon = AnonymousValue.From(3);&#10;        int arg = 4;&#10;&#10;        var invoker = AnonymousInvokers.GetFuncInvoker&lt;int, int&gt;(func);&#10;        var result = invoker(func, ref anon, MutatingBehaviour.Mutate, ref arg);&#10;&#10;        Assert.That(result, Is.EqualTo(7));&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(7));&#10;    }&#10;&#10;    [Test]&#10;    public void GetActionInvoker_ThrowsOnInvalidDelegate()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx;&#10;        Assert.Throws&lt;ArgumentException&gt;(() =&gt; AnonymousInvokers.GetActionInvoker(func));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvoker_ThrowsOnInvalidReturnType()&#10;    {&#10;        Func&lt;int, int&gt; func = ctx =&gt; ctx;&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; AnonymousInvokers.GetFuncInvoker&lt;string&gt;(func));&#10;    }&#10;&#10;    [Test]&#10;    public void GetFuncInvokerTArgTReturn_ThrowsOnInvalidArgType()&#10;    {&#10;        Func&lt;int, int, int&gt; func = (ctx, arg) =&gt; ctx + arg;&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; AnonymousInvokers.GetFuncInvoker&lt;string, int&gt;(func));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousValueTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/AnonymousValueTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousValue))]&#10;public class AnonymousValueTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(AnonymousValue))]&#10;public class AnonymousValueTest&#10;{&#10;    [TestCase('a')]&#10;    [TestCase('Z')]&#10;    public void Char_Roundtrip(char value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;char&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;char&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(char)));&#10;    }&#10;&#10;    [TestCase(true)]&#10;    [TestCase(false)]&#10;    public void Bool_Roundtrip(bool value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;bool&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;bool&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(bool)));&#10;    }&#10;&#10;    [TestCase((byte)1)]&#10;    [TestCase(byte.MaxValue)]&#10;    public void Byte_Roundtrip(byte value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;byte&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;byte&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(byte)));&#10;    }&#10;&#10;    [TestCase((sbyte)-1)]&#10;    [TestCase(sbyte.MaxValue)]&#10;    public void SByte_Roundtrip(sbyte value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;sbyte&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;sbyte&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(sbyte)));&#10;    }&#10;&#10;    [TestCase((short)-123)]&#10;    [TestCase(short.MaxValue)]&#10;    public void Short_Roundtrip(short value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;short&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;short&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(short)));&#10;    }&#10;&#10;    [TestCase((ushort)123)]&#10;    [TestCase(ushort.MaxValue)]&#10;    public void UShort_Roundtrip(ushort value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;ushort&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;ushort&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(ushort)));&#10;    }&#10;&#10;    [TestCase(-123)]&#10;    [TestCase(int.MaxValue)]&#10;    public void Int_Roundtrip(int value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;int&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(int)));&#10;    }&#10;&#10;    [TestCase(uint.MaxValue)]&#10;    [TestCase(123u)]&#10;    public void UInt_Roundtrip(uint value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;uint&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;uint&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(uint)));&#10;    }&#10;&#10;    [TestCase(-123L)]&#10;    [TestCase(long.MaxValue)]&#10;    public void Long_Roundtrip(long value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;long&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;long&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(long)));&#10;    }&#10;&#10;    [TestCase(ulong.MaxValue)]&#10;    [TestCase(123UL)]&#10;    public void ULong_Roundtrip(ulong value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;ulong&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;ulong&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(ulong)));&#10;    }&#10;&#10;    [TestCase(1.23f)]&#10;    [TestCase(float.MaxValue)]&#10;    public void Float_Roundtrip(float value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;float&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;float&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(float)));&#10;    }&#10;&#10;    [TestCase(1.23)]&#10;    [TestCase(double.MaxValue)]&#10;    public void Double_Roundtrip(double value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;double&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;double&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(double)));&#10;    }&#10;&#10;    [TestCase(1.23)]&#10;    [TestCase(123456789.123456789)]&#10;    public void Decimal_Roundtrip(decimal value)&#10;    {&#10;        var anon = AnonymousValue.From(value);&#10;        Assert.That(anon.Is&lt;decimal&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;decimal&gt;(), Is.EqualTo(value));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(decimal)));&#10;    }&#10;&#10;    [Test]&#10;    public void Reference_Roundtrip()&#10;    {&#10;        var obj = new object();&#10;        var anon = AnonymousValue.From(obj);&#10;        Assert.That(anon.Is&lt;object&gt;(), Is.True);&#10;        Assert.That(anon.As&lt;object&gt;(), Is.SameAs(obj));&#10;        Assert.That(anon.GetUnderlyingType(), Is.EqualTo(typeof(object)));&#10;    }&#10;&#10;    [Test]&#10;    public void Set_UpdatesValueAndType()&#10;    {&#10;        var anon = AnonymousValue.From(1);&#10;        anon.Set(2);&#10;        Assert.That(anon.As&lt;int&gt;(), Is.EqualTo(2));&#10;        anon.Set(&quot;hello&quot;);&#10;        Assert.That(anon.As&lt;string&gt;(), Is.EqualTo(&quot;hello&quot;));&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_WorksForSameValue()&#10;    {&#10;        var a = AnonymousValue.From(123);&#10;        var b = AnonymousValue.From(123);&#10;        Assert.That(a, Is.EqualTo(b));&#10;        Assert.That(a == b, Is.True);&#10;        Assert.That(a != b, Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void Equals_WorksForDifferentValue()&#10;    {&#10;        var a = AnonymousValue.From(123);&#10;        var b = AnonymousValue.From(456);&#10;        Assert.That(a, Is.Not.EqualTo(b));&#10;        Assert.That(a == b, Is.False);&#10;        Assert.That(a != b, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void As_InvalidCast_Throws()&#10;    {&#10;        var anon = AnonymousValue.From(123);&#10;        Assert.Throws&lt;InvalidCastException&gt;(() =&gt; anon.As&lt;string&gt;());&#10;    }&#10;&#10;    [Test]&#10;    public void Set_NullReference_Throws()&#10;    {&#10;        var anon = AnonymousValue.From(123);&#10;        Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; anon.Set&lt;object&gt;(null!));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/Anonymous/ResultTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/Anonymous/ResultTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(Result))]&#10;public class ResultTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.Anonymous;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(Result))]&#10;public class ResultTest&#10;{&#10;    [Test]&#10;    public void Result_Success_CreatesSuccessResult()&#10;    {&#10;        var result = Result.Success();&#10;        Assert.That(result.IsSuccess, Is.True);&#10;        Assert.That(result.Exception, Is.Null);&#10;        Assert.That((bool)result, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void Result_Failure_CreatesFailureResult()&#10;    {&#10;        var ex = new InvalidOperationException(&quot;fail&quot;);&#10;        var result = Result.Failure(ex);&#10;        Assert.That(result.IsSuccess, Is.False);&#10;        Assert.That(result.Exception, Is.EqualTo(ex));&#10;        Assert.That((bool)result, Is.False);&#10;    }&#10;&#10;    [Test]&#10;    public void ResultT_Success_CreatesSuccessResult()&#10;    {&#10;        var value = 42;&#10;        var result = Result&lt;int&gt;.Success(value);&#10;        Assert.That(result.IsSuccess, Is.True);&#10;        Assert.That(result.Value, Is.EqualTo(value));&#10;        Assert.That(result.Exception, Is.Null);&#10;        Assert.That((bool)result, Is.True);&#10;    }&#10;&#10;    [Test]&#10;    public void ResultT_Failure_CreatesFailureResult()&#10;    {&#10;        var ex = new ArgumentException(&quot;fail&quot;);&#10;        var result = Result&lt;string&gt;.Failure(ex);&#10;        Assert.That(result.IsSuccess, Is.False);&#10;        Assert.That(result.Value, Is.Null);&#10;        Assert.That(result.Exception, Is.EqualTo(ex));&#10;        Assert.That((bool)result, Is.False);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/ClosureTests/CustomClosureTest.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/CustomClosureTest.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(CustomClosure&lt;,&gt;))]&#10;public class CustomClosureTest {&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;using System;&#10;&#10;namespace ClosureTests;&#10;&#10;[TestFixture]&#10;[TestOf(typeof(CustomClosure&lt;,&gt;))]&#10;public class CustomClosureTest&#10;{&#10;    [Test]&#10;    public void CustomClosure_CreatesCorrectly()&#10;    {&#10;        int context = 42;&#10;        Func&lt;int, int&gt; func = x =&gt; x + 1;&#10;        var closure = Closure.Custom(context, func);&#10;&#10;        Assert.That(closure.Context, Is.EqualTo(context));&#10;        Assert.That(closure.Delegate, Is.EqualTo(func));&#10;    }&#10;&#10;    [Test]&#10;    public void CustomClosure_DelegateCanBeInvoked()&#10;    {&#10;        string context = &quot;Hello&quot;;&#10;        Func&lt;string, string, string&gt; func = (ctx, arg) =&gt; $&quot;{ctx}, {arg}!&quot;;&#10;        var closure = Closure.Custom(context, func);&#10;&#10;        // Manually invoke the delegate, passing context as the first argument&#10;        var result = closure.Delegate.Invoke(closure.Context, &quot;World&quot;);&#10;        Assert.That(result, Is.EqualTo(&quot;Hello, World!&quot;));&#10;    }&#10;&#10;    [Test]&#10;    public void CustomClosure_WorksWithAction()&#10;    {&#10;        int context = 10;&#10;        int calledWith = 0;&#10;        Action&lt;int, int&gt; action = (ctx, arg) =&gt; calledWith = ctx + arg;&#10;        var closure = Closure.Custom(context, action);&#10;&#10;        closure.Delegate.Invoke(closure.Context, 5);&#10;        Assert.That(calledWith, Is.EqualTo(15));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>