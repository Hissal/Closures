<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/ClosureTests/ActionTests/AnonymousClosure/AnonymousClosureTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/ClosureTests/ActionTests/AnonymousClosure/AnonymousClosureTests.cs" />
              <option name="originalContent" value="using Closures;&#10;&#10;namespace ClosureTests.ActionTests.AnonymousClosure;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    // Normal Actions&#10;    [Test]&#10;    public void ClosureActionAsAnonymousAndBack() {&#10;        int expected = 10;&#10;        int received = 0;&#10;        &#10;        var closureAction = Closure.Action(expected, context =&gt; received = context);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int&gt;().Invoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context value.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void ClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    [Test]&#10;    public void ClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, ref int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureRefAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    // Mutating Actions&#10;    &#10;}" />
              <option name="updatedContent" value="using Closures;&#10;&#10;namespace ClosureTests.ActionTests.AnonymousClosure;&#10;&#10;[TestFixture]&#10;public class AnonymousClosureTests {&#10;    // Normal Actions&#10;    [Test]&#10;    public void ClosureActionAsAnonymousAndBack() {&#10;        int expected = 10;&#10;        int received = 0;&#10;        &#10;        var closureAction = Closure.Action(expected, context =&gt; received = context);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int&gt;().Invoke();&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context value.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void ClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    [Test]&#10;    public void ClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 5;&#10;        int expected = context + arg; // context + arg&#10;        int received = 0;&#10;&#10;        var closureAction = Closure.Action(context, (int c, ref int a) =&gt; received = c + a);&#10;        var anonymous = closureAction.AsAnonymous();&#10;        anonymous.AsClosureRefAction&lt;int, int&gt;().Invoke(arg);&#10;        &#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;ClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a ClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;Anonymous closure did not receive the expected context and argument values.&quot;);&#10;        });&#10;    }&#10;    &#10;    // Mutating Actions&#10;    [Test]&#10;    public void MutatingClosureActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int expected = context + 5;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c) =&gt; c += 5, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureAction&lt;int&gt;().Invoke();&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureAction&lt;int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureAction&lt;int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureAction did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void MutatingClosureActionWithArgAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 7;&#10;        int expected = context + arg;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c, int a) =&gt; c += a, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureAction&lt;int, int&gt;().Invoke(arg);&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureActionWithArg did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;&#10;    [Test]&#10;    public void MutatingClosureRefActionAsAnonymousAndBack() {&#10;        int context = 10;&#10;        int arg = 3;&#10;        int expected = context + arg;&#10;        int received = 0;&#10;&#10;        var closure = Closure.Action(context, (ref int c, ref int a) =&gt; c += a, MutatingClosureBehaviour.Retain);&#10;        var anonymous = closure.AsAnonymous();&#10;        anonymous.AsMutatingClosureRefAction&lt;int, int&gt;().Invoke(ref arg);&#10;        received = anonymous.Context.As&lt;int&gt;();&#10;&#10;        Assert.Multiple(() =&gt; {&#10;            Assert.That(anonymous.Is&lt;MutatingClosureRefAction&lt;int, int&gt;&gt;(), Is.True, &quot;Anonymous closure should be a MutatingClosureRefAction&lt;int, int&gt;.&quot;);&#10;            Assert.That(received, Is.EqualTo(expected), &quot;MutatingClosureRefAction did not mutate context as expected.&quot;);&#10;        });&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>